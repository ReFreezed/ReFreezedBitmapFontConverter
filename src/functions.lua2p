--[[============================================================
--=
--=  Functions
--=
--=-------------------------------------------------------------
--=
--=  ReFreezed Bitmap Font converter
--=  by Marcus 'ReFreezed' ThunstrÃ¶m
--=
--==============================================================

	addCodepoint
	addKerningPairs
	connectToDirectory, mustConnectToDirectory
	errorf, warning, errorLine
	fileError, fileWarning, fileAssert
	getDirectoryItems
	getFileContents, isFile, isDirectory, eachLine
	getFilename, getDirectory, getBasename, getBasenameAndExtensionWithDot
	getIconCodepoint, getIcons, getIconCount, setIconCodepoint, isCodepointInPua
	getImageContentBounds
	getLast
	getUnicodeBlockName
	normalizePath
	outputImageFilenameBaseToFilename
	parseBool, parseNumber, parseInt*, parseUint*, parseUint*Sides
	print, printf
	processPathTemplate
	reservePathForReading, reservePathForWriting
	S
	triml, trimr, trim

--============================================================]]

_G.F = string.format



-- addCodepoint( rbmfFile, row, cp, icon=nil )
function _G.addCodepoint(rbmfFile, row, cp, icon)
	local cpsOnRow           = rbmfFile.codepoints[row] or {}
	rbmfFile.codepoints[row] = cpsOnRow
	table.insert(cpsOnRow, cp)

	rbmfFile.codepointLines[cp] = rbmfFile.ln

	if icon then  table.insert(rbmfFile.icons, icon)  end

	rbmfFile.lastRow = math.max(rbmfFile.lastRow, row)
end



local function addKerningPair(rbmfFile, firstCp, secondCp, offset)
	local pair = utf8.char(firstCp, secondCp)

	if rbmfFile.kerningLines[pair] then
		fileWarning(
			rbmfFile, "Kerning for '%s' (codepoints %d and %d) is already defined (line %d). Replacing old value.\n",
			pair, firstCp, secondCp, rbmfFile.kerningLines[pair]
		)
	else
		rbmfFile.kerningLines[pair] = rbmfFile.ln
	end

	rbmfFile.kernings[pair] = offset
end

function _G.addKerningPairs(rbmfFile, firsts, seconds, offset, back)
	for _, firstCp in utf8.codes(firsts) do
		for _, secondCp in utf8.codes(seconds) do
			addKerningPair(rbmfFile, firstCp, secondCp, offset)
			if back then  addKerningPair(rbmfFile, secondCp, firstCp, offset)  end
		end
	end
end



function _G.triml(s)
	return (s:gsub("^ +", ""))
end

function _G.trimr(s)
	return (s:gsub(" +$", ""))
end

function _G.trim(s)
	return (s:gsub("^ +", ""):gsub(" +$", ""))
end



function _G.errorf(s, ...)
	error(F(s, ...), 2)
end

function _G.warning(s, ...)
	_G.warningCount = warningCount + 1
	io.stderr:write(F("WARNING(%d): "..s, warningCount, ...), "\n")
end

-- errorLine( message )
-- errorLine( messageFormat, value1, ... )
function _G.errorLine(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	!if DEV then
		io.stderr:write("ERROR: ", debug.traceback(s, 2), "\n\n")
	!else
		io.stderr:write("ERROR: ", s, "\n\n")
	!end
	os.exit(1)
end



function _G.fileError(info, s, ...)
	s = (
		info.ln > 0
		and F("%s:%d: "..s, getFilename(info.path), info.ln, ...)
		or  F("%s: "   ..s, getFilename(info.path),          ...)
	)
	!if DEV then
		io.stderr:write("ERROR: ", debug.traceback(s, 2), "\n\n")
	!else
		io.stderr:write("ERROR: ", s, "\n\n")
	!end
	os.exit(1)
end

function _G.fileWarning(info, s, ...)
	if info.ln > 0 then
		warning("%s:%d: "..s, getFilename(info.path), info.ln, ...)
	else
		warning("%s: "   ..s, getFilename(info.path),          ...)
	end
end

-- value1, ... = fileAssert( info, success, value1, ...  )
--               fileAssert( info, success, message )
function _G.fileAssert(info, ok, ...)
	if not ok then  fileError(info, "%s", (...))  end
	return ...
end



local function cmdCapture(cmd)
	local stream = assert(io.popen(cmd, "r"))
	local output = assert(stream:read"*a")
	stream:close()
	return output
end

function _G.getDirectoryItems(dir)
	mustConnectToDirectory(Path(dir):toString())
	return LF.getDirectoryItems("")
end



function _G.getFilename(path)
	return (path:gsub("^.*/", ""))
end

function _G.getDirectory(path)
	if not path:find("/", 1, true) then  return "."  end

	dir = path:gsub("/[^/]+$", "")

	if dir == "" or dir:find"^%a:$" then
		dir = dir.."/"
	end

	return dir
end

function _G.getBasename(filename)
	local basename = filename:gsub("%.[^.]+$", "")
	return basename ~= "" and basename or filename
end

function _G.getBasenameAndExtensionWithDot(filename)
	local basename = getBasename(filename)
	return basename, filename:sub(#basename+1)
end



function _G.normalizePath(path)
	return Path(path):toString()
end



do
	local iconCps   = {}
	local iconCount = 0
	local nextPuaCp = 0xE000 -- Unicode PUA: U+E000-U+F8FF, U+F0000-U+FFFFD and U+100000-U+10FFFD (https://en.wikipedia.org/wiki/Private_Use_Areas)

	function _G.getIconCodepoint(icon)
		local cp = iconCps[icon]
		if cp then  return cp  end

		if     nextPuaCp == 0xF8FF   + 1 then  nextPuaCp = 0xF0000
		elseif nextPuaCp == 0xFFFFD  + 1 then  nextPuaCp = 0x100000
		elseif nextPuaCp == 0x10FFFD + 1 then  errorLine("Too many icons! Maximum amount is %d.", (0xF8FF-0xE000+1 + 0xFFFFD-0xF0000+1 + 0x10FFFD-0x100000+1))
		end

		cp        = nextPuaCp
		nextPuaCp = nextPuaCp + 1

		iconCps[icon] = cp
		iconCount     = iconCount + 1

		return cp
	end

	function _G.getIcons()
		local icons = {}
		for icon in pairs(iconCps) do
			table.insert(icons, icon)
		end
		table.sort(icons)
		return icons
	end

	function _G.getIconCount()
		return iconCount
	end

	function _G.setIconCodepoint(icon, cp)
		if iconCps[icon] == cp then
			return
		elseif iconCps[icon] then
			errorf("Icon '%s' already has another codepoint. (new=%d, old=%d)", icon, cp, iconCps[icon])
		else
			iconCps[icon] = cp
			nextPuaCp     = math.max(nextPuaCp, cp+1)
		end
	end

	function _G.isCodepointInPua(cp)
		return (cp >= 0xE000 and cp <= 0xF8FF) or (cp >= 0xF0000 and cp <= 0xFFFFD) or (cp >= 0x100000 and cp <= 0x10FFFD)
	end
end



-- x1, x2, y1, y2 = getImageContentBounds( imageData, x1, y1, x2, y2, alphaThreshold )
-- Returns nil if the whole area is empty.
function _G.getImageContentBounds(imageData, x1, y1, x2, y2, threshold)
	local hasContent = false

	for y = y1, y2 do
		for x = x1, x2 do
			local _, _, _, a = imageData:getPixel(x, y) -- @Speed

			if a >= threshold then
				hasContent = true
				break
			end
		end

		if hasContent then  break  end
	end

	if not hasContent then  return nil  end

	local cx1 =  1/0
	local cx2 = -1/0
	local cy1 =  1/0
	local cy2 = -1/0

	for y = y1, y2 do
		for x = x1, x2 do
			local _, _, _, a = imageData:getPixel(x, y) -- @Speed

			if a >= threshold then
				cx1 = math.min(cx1, x)
				cx2 = math.max(cx2, x)
				cy1 = math.min(cy1, y)
				cy2 = math.max(cy2, y)
			end
		end
	end

	return cx1, cx2, cy1, cy2
end



function _G.getUnicodeBlockName(cp)
	for _, block in ipairs(require"unicodeBlocks") do
		if cp >= block.from and cp <= block.to then
			return block.name
		end
	end
	return "Unknown Block"
end



-- contents|nil, error = getFileContents( path|pathObj )
function _G.getFileContents(pathObj)
	if type(pathObj) == "string" then  pathObj = Path(pathObj)  end

	local dir, filename = pathObj:getDirectoryAndFilename()

	if not connectToDirectory(dir) then
		return nil, F("Cannot access directory '%s'.", dir)
	end

	return LF.read(filename)
end

do
	local fileInfoDummy = {}

	function _G.isFile(path)
		local dir, filename = Path(path):getDirectoryAndFilename()
		return (
			connectToDirectory(dir)
			and LF.getInfo(filename, "file", fileInfoDummy) ~= nil
		)
	end

	function _G.isDirectory(path)
		local dir, filename = Path(path):getDirectoryAndFilename()
		return (
			connectToDirectory(dir)
			and LF.getInfo(filename, "directory", fileInfoDummy) ~= nil
		)
	end
end

-- for ln, line in eachLine( path|pathObj ) do
function _G.eachLine(pathObj)
	if type(pathObj) == "string" then  pathObj = Path(pathObj)  end

	local dir, filename = pathObj:getDirectoryAndFilename()

	mustConnectToDirectory(dir)

	local lineIter = LF.lines(filename)
	local ln       = 0

	return function()
		local line = lineIter()
		if line then
			ln = ln + 1
			return ln, line
		end
	end
end



function _G.parseBool(s)
	if s == "true" then
		return true, true
	elseif s == "false" then
		return true, false
	end
	return false, F("Expected a boolean - got '%s'.", s)
end

function _G.parseNumber(s)
	local n = tonumber(s)
	if n then  return true, n  end
	return false, F("Expected a number - got '%s'.", s)
end

function _G.parseInt(s)
	if not s:find"^%-?%d+$" then
		return false, F("Expected an integer - got '%s'.", s)
	end
	return true, tonumber(s)
end
function _G.parseInt2(s)
	local nStr1, nStr2 = s:match"^(%-?%d+) +(%-?%d+)$"
	if not nStr1 then
		return false, F("Expected 2 integers - got '%s'.", s)
	end
	return true, tonumber(nStr1), tonumber(nStr2)
end
function _G.parseInt4(s)
	local nStr1, nStr2, nStr3, nStr4 = s:match"^(%-?%d+) +(%-?%d+) +(%-?%d+) +(%-?%d+)$"
	if not nStr1 then
		return false, F("Expected 4 integers - got '%s'.", s)
	end
	return true, tonumber(nStr1), tonumber(nStr2), tonumber(nStr3), tonumber(nStr4)
end

function _G.parseUint(s)
	if not s:find"^%d+$" then
		return false, F("Expected an unsigned integer - got '%s'.", s)
	end
	return true, tonumber(s)
end
function _G.parseUint2(s)
	local nStr1, nStr2 = s:match"^(%d+) +(%d+)$"
	if not nStr1 then
		return false, F("Expected 2 unsigned integers - got '%s'.", s)
	end
	return true, tonumber(nStr1), tonumber(nStr2)
end
function _G.parseUint4(s)
	local nStr1, nStr2, nStr3, nStr4 = s:match"^(%d+) +(%d+) +(%d+) +(%d+)$"
	if not nStr1 then
		return false, F("Expected 4 unsigned integers - got '%s'.", s)
	end
	return true, tonumber(nStr1), tonumber(nStr2), tonumber(nStr3), tonumber(nStr4)
end

-- vertical, horizontal = parseUint2Sides "vertical horizontal"
-- vertical, horizontal = parseUint2Sides "verticalHorizontal"
function _G.parseUint2Sides(s)
	local nStrV, nStrH = s:match"^(%d+) +(%d+)$"
	if not nStrV then
		nStrV = s:match"^(%d+)$"
		if not nStrV then
			return false, F("Expected 1 or 2 unsigned integers - got '%s'.", s)
		end
	end
	return true, tonumber(nStrV), tonumber(nStrH or nStrV)
end
-- up, right, down, left = parseUint4Sides "up right down left"
-- up, right, down, left = parseUint4Sides "up rightLeft down"
-- up, right, down, left = parseUint4Sides "upDown leftRight"
-- up, right, down, left = parseUint4Sides "upRightDownLeft"
function _G.parseUint4Sides(s)
	local nStrU, nStrR, nStrB, nStrL = s:match"^(%d+) +(%d+) +(%d+) +(%d+)$"
	if not nStrU then
		nStrU, nStrR, nStrB = s:match"^(%d+) +(%d+) +(%d+)$"
		if not nStrU then
			nStrU, nStrR = s:match"^(%d+) +(%d+)$"
			if not nStrU then
				nStrU = s:match"^(%d+)$"
				if not nStrU then
					return false, F("Expected 4, 3, 2 or 1 unsigned integers - got '%s'.", s)
				end
			end
		end
	end
	return true, tonumber(nStrU), tonumber(nStrR or nStrU), tonumber(nStrB or nStrU), tonumber(nStrL or nStrR or nStrU)
end



do
	local _print     = print
	-- local logFile = nil

	function _G.print(...)
		_print(...)

		-- logFile = logFile or LF.newFile("log.txt", "a")
		-- for i = 1, select("#", ...) do
		-- 	if i > 1 then  logFile:write("\t")  end
		-- 	logFile:write((tostring(select(i, ...)):gsub("\r?\n", "\r\n")))
		-- end
		-- logFile:write("\r\n")
	end
end

function _G.printf(s, ...)
	print(F(s, ...))
end



do
	local currentDirectory = ""

	-- success = connectToDirectory( directory )
	function _G.connectToDirectory(dir)
		if dir == currentDirectory then  return true  end

		if not physfs.mountReadDirectory(dir, false) then  return false  end

		for _, path in ipairs(physfs.getSearchPaths()) do
			assert(physfs.unmountReadDirectory(path))
		end

		assert(physfs.mountReadDirectory(dir, false))
		assert(physfs.setWriteDirectory(dir))

		currentDirectory = dir
		return true
	end

	function _G.mustConnectToDirectory(path)
		if not connectToDirectory(path) then
			errorLine("Could not access directory '%s'.", path)
		end
	end
end



function _G.processPathTemplate(rbmfFile, pathTemplate)
	return (pathTemplate:gsub("<(.-)>", function(var)
		if var == "name" then
			return getBasename(getFilename(rbmfFile.path))
		else
			fileError(rbmfFile, "Unknown variable <%s> in path '%s'.", var, pathTemplate)
		end
	end))
end



-- text = S( count [, textSingle="", textMulti="s" ] )
function _G.S(count, textSingle, textMulti)
	return (count == 1)
	   and (textSingle or "")
	   or  (textMulti  or "s")
end



function _G.outputImageFilenameBaseToFilename(filenameBase, imageIndex)
	local basename, ext = getBasenameAndExtensionWithDot(filenameBase)
	return F("%s_%d%s", basename, imageIndex-1, ext)
end



do
	local reservedPathsForReading = {}
	local reservedPathsForWriting = {}

	-- reservePathForReading( path, subjectFormat, value1, ... )
	function _G.reservePathForReading(path, subjectNew, ...)
		subjectNew = reservedPathsForReading[path] or subjectNew:format(...)

		local subjectOld = reservedPathsForWriting[path]
		if subjectOld then
			errorLine("Path collision for '%s':\n    Old purpose: %s\n    New purpose: %s", path, subjectOld, subjectNew)
		end

		reservedPathsForReading[path] = subjectNew
	end

	-- reservePathForWriting( path, subjectFormat, value1, ... )
	function _G.reservePathForWriting(path, subjectNew, ...)
		subjectNew = subjectNew:format(...)

		local subjectOld = reservedPathsForReading[path] or reservedPathsForWriting[path]
		if subjectOld then
			errorLine("Path collision for '%s':\n    Old purpose: %s\n    New purpose: %s", path, subjectOld, subjectNew)
		end

		reservedPathsForWriting[path] = subjectNew
	end
end



function _G.getLast(t)
	return t[#t]
end


