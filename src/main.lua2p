--[[============================================================
--=
--=  ReFreezed Bitmap Font converter - convert RBMF files to BMFont
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Works with LÖVE 11.3
--=
--============================================================]]

local CMD_HELP = [=[
	> RbmfConverter.exe inputPath1 [inputPath2 ...] [options]

	Options:
		--outdir   <outputDirectory>     # Where to output files. (Default: Same directory as the input.)
		--icons    <outputFilePath>      # Where to put the icons file if any icons are specified. (Default: <outputDirectory>/.fonticons)
		--mergeicons                     # Merge new icons with existing icons if the icons file exists. (Default: Icon file is replaced.)
		--maxsize  <outputImageMaxSize>  # Default: 2048
		--textfile <filePath1> [--textfile <filePath2> ...]

	Notes:
		<inputPath> can be a .rbmf file or a directory with .rbmf files.
		The filenames of outputted files is specified in the font descriptor.
		Relative --textfile paths will be relative to CWD, unlike the 'textFile' input parameter in the descriptor.
]=]



!if not TEST then

!local CMD_TITLE     = "ReFreezed Bitmap Font converter "..getReleaseVersion()
!local CMD_SEPARATOR = string.rep("-", #CMD_TITLE)

local programArguments = arg



local function RbmfFile()
	return {
		path = "",
		ln   = 0, -- Current line number.

		-- Params.
		version = 0,

		codepoints = {--[[ [row1]={cp1,...}, ... ]]},
		icons      = {--[[ iconName1,        ... ]]},

		isColored = true, -- Uncolored fonts can be optimized so the 4 channels contain different glyphs in the output.

		fontFilename = "",
		fontSize     = 0,
		fontHinting  = "normal", -- "normal"|"light"|"mono"|"none"

		textFilePaths = {--[[ path1, ... ]]},

		editAlphaThreshold = 0, -- 0 means no cleaning of font pixels.

		outputDescriptors = {--[[ outputDescriptor1, ... ]]},

		kernings = {--[[ [pair1]=offset1, ... ]]},
		--

		codepointLines = {--[[ [cp1]=ln1,   ... ]]}, -- For dupe checking.
		kerningLines   = {--[[ [pair1]=ln1, ... ]]}, -- For dupe checking.
		lastRow        = 0,

		useTextFiles   = false,
		textCodepoints = {--[[ [cp1]=true, ... ]]},
	}
end

local function OutputDescriptor()
	return {
		ln = 0,

		-- Params.
		filenameImage      = "",
		filenameDescriptor = "",

		glyphPaddingU = 0,
		glyphPaddingR = 0,
		glyphPaddingD = 0,
		glyphPaddingL = 0,

		glyphSpacingH = 0,
		glyphSpacingV = 0,

		imagePaddingH = 0,
		imagePaddingV = 0,

		outlineWidth = 0,
		outlineColor = {0,0,0,1},

		customValues = {--[[ [1]=k1, [k1]=v1, ... ]]},
		--

		pathImage      = "",
		pathDescriptor = "",

		couldPack = false,
		pack      = false,
	}
end



function love.errorhandler(err)
	io.stderr:write(debug.traceback("Error: "..tostring(err), 3), "\n", "\n") -- @UX
end
love.errhand = nil



function love.run()
	local startTime = require"socket".gettime()

	package.path = "?.lua;srcgen/?.lua"
	love.filesystem.setRequirePath(package.path)

	_G.Path   = require"path"
	_G.physfs = require"physfs"
	_G.socket = require"socket"
	_G.utf8   = require"utf8"

	require"functions"

	_G.LF = love.filesystem
	_G.LI = love.image

	_G.warningCount = 0

	io.stdout:setvbuf"no"
	io.stderr:setvbuf"no"

	--
	-- Get args
	--

	local in_paths           = {}
	local in_textFilesForAll = {}
	local out_directory      = ""
	local out_iconsPath      = ""
	local out_mergeIcons     = false
	local out_imageMaxSize   = 2048

	local args = love.arg.parseGameArguments(programArguments)
	local i    = 1

	args[1] = args[1] or "--help"

	while args[i] do
		if not args[i]:find"^%-" then
			table.insert(in_paths, normalizePath(args[i])) -- Directory or file.
			i = i+1

		elseif args[i] == "--help" then
			print!(CMD_TITLE)
			print()
			print((CMD_HELP:gsub("\t", "    ")))
			return

		elseif args[i] == "--outdir" then
			out_directory = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			out_directory = normalizePath(out_directory)
			i = i+2

		elseif args[i] == "--maxsize" then
			local v          = args[i+1] or errorLine("Argument: Missing number after '%s'.", args[i])
			out_imageMaxSize = tonumber(v:match"^%-?%d+$") or errorLine("Argument: '%s' is not an integer.", v)
			if out_imageMaxSize < 1 then
				errorLine("--maxsize must be positive.")
			end
			i = i+2

		elseif args[i] == "--icons" then
			out_iconsPath = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			out_iconsPath = normalizePath(out_iconsPath)
			i = i+2

		elseif args[i] == "--mergeicons" then
			out_mergeIcons = true
			i = i+1

		elseif args[i] == "--textfile" then
			local path = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			table.insert(in_textFilesForAll, normalizePath(path))
			i = i+2

		elseif args[i] == "--nogc" then
			collectgarbage("stop")
			i = i+1

		else
			errorLine("Argument: Unknown option '%s'.", args[i])
		end
	end

	if not in_paths[1] then
		errorLine("Argument: Missing any input path.") -- @UX: Show help.
	end

	print!(CMD_TITLE)
	print!(CMD_SEPARATOR)
	print(os.date"         %Y-%m-%d %H:%M:%S")
	printf(      "  Input: %s", table.concat(in_paths, ", "))
	printf(      " Output: %s", (out_directory ~= "" and out_directory or "(in input directory)"))
	printf(      "MaxSize: %d", out_imageMaxSize)
	print!(CMD_SEPARATOR)

	local iconImageData = LI.newImageData("gfx/appIcon16.png") -- We do this before starting to tinker with PhysFS.

	-- Collect all paths to process.
	local rbmfFiles = {}

	for _, path in ipairs(in_paths) do
		if isFile(path) then
			local rbmfFile = RbmfFile()
			rbmfFile.path  = path
			table.insert(rbmfFiles, rbmfFile)
		else
			for _, filename in ipairs(getDirectoryItems(path)) do
				if filename:find"%.rbmf$" then
					local rbmfFile = RbmfFile()
					rbmfFile.path  = path.."/"..filename
					table.insert(rbmfFiles, rbmfFile)
				end
			end
		end
	end

	--
	-- Load existing icons
	--
	if out_iconsPath == "" and out_directory ~= "" then
		out_iconsPath = Path(".fonticons", out_directory):toString()
	end

	if out_mergeIcons and out_iconsPath ~= "" and isFile(out_iconsPath) then
		for ln, line in eachLine(out_iconsPath) do
			local cp, icon = line:match"^ *(%d+) +(%S+) *$"
			cp             = tonumber(cp)

			if not cp then  errorLine("%s:%d: Bad line format: %s", out_iconsPath, ln, line)  end

			setIconCodepoint(icon, cp)
		end
	end

	--
	-- Read rbmf files
	--
	for _, rbmfFile in ipairs(rbmfFiles) do
		if rbmfFile.path == "" then
			errorLine("An input path is empty.")
		end

		printf("Loading RBMF: %s", rbmfFile.path)

		local section         = ""
		local sectionLines    = {}
		local currentOutDescr = nil

		for ln, line in eachLine(rbmfFile.path) do
			rbmfFile.ln = ln
			local k, v  = line:match"^([%a][%w_.]+)=(.*)$"

			-- Empty/comment.
			if line == "" or line:find"^#" then
				-- void

			-- Version line.
			elseif rbmfFile.version == 0 then
				if k ~= "version" then
					fileError(rbmfFile, "The first line must be the file version number!")
				end

				rbmfFile.version = fileAssert(rbmfFile, parseUint(v))
				if rbmfFile.version ~= 1 then
					fileError(rbmfFile, "Unsupported file version '%d'.", rbmfFile.version)
				end

			-- Section start.
			elseif line:find"^%[" then
				section = line:match"%[(%w+)%]" or fileError(rbmfFile, "Invalid section name line format: %s", line)

				if sectionLines[section] and not (section == "out") then
					fileError(rbmfFile, "Duplicate section '%s'. (Previous is on line %d)", section, sectionLines[section])
				end

				sectionLines[section] = ln

				if section == "out" then
					currentOutDescr    = OutputDescriptor()
					currentOutDescr.ln = ln
					table.insert(rbmfFile.outputDescriptors, currentOutDescr)
				else
					currentOutDescr = nil
				end

				if section:find"^%d+$" then
					rbmfFile.lastRow = math.max(rbmfFile.lastRow, tonumber(section))
				end

			elseif not k then
				fileError(rbmfFile, "Invalid key-value line format: %s", line)

			----------------------------------------------------------------

			elseif section == "in" then
				v = trim(v)

				if k == "colored" then
					rbmfFile.isColored = fileAssert(rbmfFile, parseBool(v))

				elseif k == "fontFile" then
					rbmfFile.fontFilename = (v ~= "" and v or fileError(rbmfFile, "TrueType font path cannot be empty."))
				elseif k == "fontSize" then
					rbmfFile.fontSize = fileAssert(rbmfFile, parseUint(v))
					if rbmfFile.fontSize < 1 then
						fileError(rbmfFile, "TrueType font size must be positive. (Value is '%s')", v)
					end
				elseif k == "fontHinting" then
					rbmfFile.fontHinting = v
					if not (v == "normal" or v == "light" or v == "mono" or v == "none") then
						fileError(rbmfFile, "Invalid TrueType font hinting '%s'. (Valid values: normal, light, mono, none)", v)
					end

				elseif k == "textFile" then
					-- Note: Paths are relative to inputPath, unlike the --textfile argument.
					local path = (v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					table.insert(rbmfFile.textFilePaths, path)

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "edit" then
				v = trim(v)

				if k == "alphaThreshold" then
					rbmfFile.editAlphaThreshold = fileAssert(rbmfFile, parseNumber(v))
					if rbmfFile.editAlphaThreshold < 0 or rbmfFile.editAlphaThreshold > 1 then
						fileError(rbmfFile, "Alpha threshold must be between 0 and 1. (Value is '%s')", v)
					end

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "out" then
				v = trim(v)

				if k == "fileImage" then
					local path                    = normalizePath(v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					currentOutDescr.filenameImage = processPathTemplate(rbmfFile, path)
					currentOutDescr.pathImage     = Path(currentOutDescr.filenameImage, out_directory):toString()
				elseif k == "fileDescriptor" then
					local path                         = normalizePath(v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					currentOutDescr.filenameDescriptor = processPathTemplate(rbmfFile, path)
					currentOutDescr.pathDescriptor     = Path(currentOutDescr.filenameDescriptor, out_directory):toString()

				elseif k == "glyphPadding" then
					currentOutDescr.glyphPaddingU, currentOutDescr.glyphPaddingR, currentOutDescr.glyphPaddingD, currentOutDescr.glyphPaddingL = fileAssert(rbmfFile, parseUint4Sides(v))
				elseif k == "glyphSpacing" then
					currentOutDescr.glyphSpacingV, currentOutDescr.glyphSpacingH = fileAssert(rbmfFile, parseUint2Sides(v))

				elseif k == "imagePadding" then
					currentOutDescr.imagePaddingV, currentOutDescr.imagePaddingH = fileAssert(rbmfFile, parseUint2Sides(v))

				elseif k == "outlineWidth" then
					currentOutDescr.outlineWidth = fileAssert(rbmfFile, parseUint(v))
				elseif k == "outlineColor" then
					local r, g, b, a = v:match"^(%d*%.?%d+) +(%d*%.?%d+) +(%d*%.?%d+) +(%d*%.?%d+)$"

					r = tonumber(r)
					g = tonumber(g)
					b = tonumber(b)
					a = tonumber(a)

					if not (r and g and b and a) then
						fileError(rbmfFile, "Invalid color format: %s", v)
					end

					currentOutDescr.outlineColor[1] = math.min(math.max(r, 0), 1)
					currentOutDescr.outlineColor[2] = math.min(math.max(g, 0), 1)
					currentOutDescr.outlineColor[3] = math.min(math.max(b, 0), 1)
					currentOutDescr.outlineColor[4] = math.min(math.max(a, 0), 1)

				elseif k:find"^custom%.[%a_][%w_]*$" then
					k = k:sub(8)

					if currentOutDescr.customValues[k] == nil then
						table.insert(currentOutDescr.customValues, k)
					end

					currentOutDescr.customValues[k] = v

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section:find"^%d+$" then
				if k == "glyphs" then
					local row = tonumber(section)

					for _, cp in utf8.codes(v) do
						if rbmfFile.codepointLines[cp] then
							fileError(
								rbmfFile, "Glyph '%s' (codepoint %d) already appeared previously on line %d.",
								utf8.char(cp), cp, rbmfFile.codepointLines[cp]
							)
						end

						addCodepoint(rbmfFile, row, cp, nil)
					end

				else
					v = trim(v)

					if k == "icons" then
						local row = tonumber(section)

						for icon in v:gmatch"%S+" do
							local cp = getIconCodepoint(icon)

							if rbmfFile.codepointLines[cp] then
								fileError(rbmfFile, "Icon '%s' already appeared previously on line %d.", icon, rbmfFile.codepointLines[cp])
							end

							addCodepoint(rbmfFile, row, cp, icon)
						end

					else
						fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
					end
				end

			----------------------------------------------------------------

			elseif section == "kerning" then
				v = trim(v)

				if k == "forward" then
					local firsts, seconds, thirds, offset = v:match"^(%S+) +(%S+) +(%S+) +(%S+)$"
					if not firsts then
						firsts, seconds, offset = v:match"^(%S+) +(%S+) +(%S+)$"
					end
					if not firsts then
						fileError(rbmfFile, "Invalid 'forward' kerning value format '%s'. (Format is 'firstGlyphs secondGlyphs [thirdGlyphs] offset').", v)
					end

					offset = fileAssert(rbmfFile, parseInt(offset))

					addKerningPairs(rbmfFile, firsts, seconds, offset, false)
					if thirds then  addKerningPairs(rbmfFile, seconds, thirds, offset, false)  end

				elseif k == "bothways" then
					local firsts, seconds, offset = v:match"^(%S+) +(%S+) +(%S+)$"

					if not firsts then
						fileError(rbmfFile, "Invalid 'bothways' kerning value format '%s'. (Format is 'firstGlyphs secondGlyphs offset').", v)
					end

					offset = fileAssert(rbmfFile, parseInt(offset))

					addKerningPairs(rbmfFile, firsts, seconds, offset, true)

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "" then
				fileError(rbmfFile, "Expected a section.")
			else
				rbmfFile.ln = sectionLines[section]
				fileError(rbmfFile, "Unknown section name '%s'.")
			end
		end
		rbmfFile.ln = 0

		if not rbmfFile.outputDescriptors[1] then
			fileError(rbmfFile, "No outputs specified.")
		end

		if rbmfFile.textFilePaths[1] and rbmfFile.fontFilename == "" then
			fileError(rbmfFile, "%d text file%s was specified, but no TrueType font.", #rbmfFile.textFilePaths, S(#rbmfFile.textFilePaths))
		end

		if rbmfFile.fontFilename ~= "" and rbmfFile.fontSize == 0 then
			fileError(rbmfFile, "A TrueType font was specified, but no font size.", #rbmfFile.textFilePaths, S(#rbmfFile.textFilePaths))
		end
		if rbmfFile.fontSize > 0 and rbmfFile.fontFilename == "" then
			fileError(rbmfFile, "A font size was specified, but no TrueType font.", #rbmfFile.textFilePaths, S(#rbmfFile.textFilePaths))
		end

		rbmfFile.useTextFiles = (in_textFilesForAll[1] or rbmfFile.textFilePaths[1]) ~= nil

		if not rbmfFile.useTextFiles and rbmfFile.lastRow == 0 then
			fileError(rbmfFile, "No glyphs specified or imported from text files.")
		end

		for _, outDescr in ipairs(rbmfFile.outputDescriptors) do
			if outDescr.filenameImage == "" then
				rbmfFile.ln = outDescr.ln
				fileWarning(rbmfFile, "No image file specified for this output.")
				rbmfFile.ln = 0
			end
			if outDescr.filenameDescriptor == "" then
				rbmfFile.ln = outDescr.ln
				fileWarning(rbmfFile, "No descriptor file specified for this output.")
				rbmfFile.ln = 0
			end
		end
	end

	--
	-- Load glyph filter text files
	--
	for _, rbmfFile in ipairs(rbmfFiles) do
		if rbmfFile.useTextFiles then
			local function processTextFile(pathObj, textCpSet)
				printf("Loading text file: %s", pathObj:toString())

				local s, err = getFileContents(pathObj)
				if not s then
					errorLine("Could not open text file '%s'. (%s)", pathObj:toString(), err)
				end

				for _, cp in utf8.codes(s) do
					if cp >= 32 then  textCpSet[cp] = true  end -- @Robustness: Better printable character check.
				end
			end

			for _, path in ipairs(in_textFilesForAll) do -- @Speed: Only process these files from args once.
				processTextFile(Path(path), rbmfFile.textCodepoints)
			end
			for _, path in ipairs(rbmfFile.textFilePaths) do
				processTextFile(Path(path, Path("..", rbmfFile.path)), rbmfFile.textCodepoints)
			end
		end
	end

	--
	-- Convert font files
	--

	for _, rbmfFile in ipairs(rbmfFiles) do
		--
		-- Load input image
		--
		local in_imageData
		local in_lineHeight, in_lineDist
		local glyphs = {}

		-- Vector font
		----------------

		if rbmfFile.fontFilename ~= "" then
			if not love.window then
				require"love.window"
				require"love.graphics"
				require"love.font"

				-- @UX: Can we make the window not grab focus somehow?
				love.window.setMode(1, 1, {borderless=true, vsync=false, x=0, y=0})
				love.window.setIcon(iconImageData)
				love.window.minimize()
			end

			local LG = love.graphics

			local pathObj = Path("..", rbmfFile.path)
			pathObj:append(rbmfFile.fontFilename)

			if not connectToDirectory(pathObj:getDirectory()) then
				errorLine("Could not access directory '%s'.", pathObj:getDirectory())
			end

			printf("Loading vector font: %s", pathObj:toString())
			local font = LG.newFont(pathObj:getFilename(), rbmfFile.fontSize, rbmfFile.fontHinting)

			in_lineHeight = font:getHeight()
			in_lineDist   = in_lineHeight + 1

			-- Collect all glyphs. Note that we set the coords later.
			local missingCps = {}

			for cp in pairs(rbmfFile.textCodepoints) do -- textCodepoints should be empty if useTextFiles is unset.
				if not font:hasGlyphs(utf8.char(cp)) then
					local blockName       = getUnicodeBlockName(cp)
					missingCps[blockName] = missingCps[blockName] or {}
					table.insert(missingCps[blockName], cp)
				else
					local glyphInfo = {cp=cp, inX1=nil, inY1=nil, inX2=nil, inY2=nil, inW=nil, inH=nil}
					table.insert(glyphs, glyphInfo)
				end
			end

			for row, cpsOnRow in pairs(rbmfFile.codepoints) do
				for _, cp in ipairs(cpsOnRow) do
					if rbmfFile.textCodepoints[cp] then
						-- void
					elseif not font:hasGlyphs(utf8.char(cp)) then
						local blockName       = getUnicodeBlockName(cp)
						missingCps[blockName] = missingCps[blockName] or {}
						table.insert(missingCps[blockName], cp)
					else
						local glyphInfo = {cp=cp, inX1=nil, inY1=nil, inX2=nil, inY2=nil, inW=nil, inH=nil}
						table.insert(glyphs, glyphInfo)
					end
				end
			end

			if not glyphs[1] then
				fileError(rbmfFile, "No glyphs to export from fontFile '%s'.", rbmfFile.fontFilename)
			end

			if next(missingCps) then
				local blockNames = {}

				for blockName, cps in pairs(missingCps) do
					table.insert(blockNames, blockName)
					table.sort(cps)
				end

				table.sort(blockNames)

				for _, blockName in ipairs(blockNames) do
					local cps = missingCps[blockName]
					warning(
						"%s: Font is missing %d '%s' codepoints:\n  %s",
						rbmfFile.fontFilename, #cps, blockName, table.concat(cps, " ")
					)
				end
			end

			-- Figure out virtual input image size and glyph coords.
			local virtual_imageMaxSize = LG.getSystemLimits().texturesize
			local virtual_imageWidth   = 0
			local virtual_imageHeight  = 0
			local x1                   = 1/0
			local y1                   = -in_lineHeight

			for _, glyphInfo in ipairs(glyphs) do
				local c = utf8.char(glyphInfo.cp)
				local w = font:getWidth(c)

				if x1+w-1 > virtual_imageMaxSize then
					virtual_imageHeight = virtual_imageHeight + in_lineHeight -- @Robustness: Limit the height!
					x1                  = 0
					y1                  = y1 + in_lineHeight
				end

				local x2 = x1 + w - 1
				local y2 = y1 + in_lineHeight - 1

				glyphInfo.inX1 = x1
				glyphInfo.inX2 = x2
				glyphInfo.inY1 = y1
				glyphInfo.inY2 = y2
				glyphInfo.inW  = x2 - x1 + 1
				glyphInfo.inH  = y2 - y1 + 1

				virtual_imageWidth = math.max(virtual_imageWidth, x2+1)
				x1                 = x2 + 1
			end

			assert(virtual_imageWidth  > 0)
			assert(virtual_imageHeight > 0)

			-- Create virtual input image.
			local fontCanvas = LG.newCanvas(virtual_imageWidth, virtual_imageHeight)

			LG.setCanvas(fontCanvas)
			LG.clear(0, 0, 0, 0)

			LG.setFont(font)
			LG.setColor(1, 1, 1)
			LG.setBlendMode("alpha", "premultiplied")
			for _, glyphInfo in ipairs(glyphs) do
				local c = utf8.char(glyphInfo.cp)
				LG.print(c, glyphInfo.inX1, glyphInfo.inY1)
			end

			LG.setCanvas(nil)

			in_imageData = fontCanvas:newImageData()
			-- assert(connectToDirectory(LF.getSaveDirectory()), LF.getSaveDirectory()) ; in_imageData:encode("png", "virt_in_image.png") -- DEBUG

			font:release()
			fontCanvas:release()

		-- Bitmap font
		----------------

		else--if rbmfFile.fontFilename == "" then
			local imagePathObj            = Path(rbmfFile.path)
			local pathSegments            = imagePathObj.path
			pathSegments[#pathSegments]   = pathSegments[#pathSegments]:gsub("%.%w+$", "")..".png" -- @Incomplete @Security: Make sure input and output image do not have the same path (or that there are any path collisions).
			local imageDir, imageFilename = imagePathObj:getDirectoryAndFilename()

			if not connectToDirectory(imageDir) then
				errorLine("Could not access directory '%s'.", imageDir)
			end
			in_imageData = LI.newImageData(imageFilename)

			-- Get separator line color.
			!GET_IMAGE_DATA_POINTER `in_imageData`
			!GET_PIXEL(`in_imageData`, `sepR`,`sepG`,`sepB`,`sepA`, 0,0)

			-- Get line height and distance.
			-- LineDistance = SeparatorHeight + LineHeight
			in_lineDist = in_imageData:getHeight() - 1

			for y = 1, in_imageData:getHeight()-1 do
				!GET_PIXEL(`in_imageData`, `r`,`g`,`b`,`a`, 1,`y`)

				if r == sepR and g == sepG and b == sepB and a == sepA then
					in_lineDist = y
					break
				end
			end

			in_lineHeight = in_lineDist - 1
			assert(in_lineHeight >= 1)

			-- Check if everything fits in the source image like the descriptor says.
			local maxRowsInFont = math.floor(in_imageData:getHeight() / in_lineDist)

			if rbmfFile.lastRow > maxRowsInFont then
				errorLine(
					"%s: Font descriptor specifies glyphs up to row %d but only %d rows fit. (Line height is %d, image height is %d)",
					imageFilename, rbmfFile.lastRow, maxRowsInFont, in_lineHeight, in_imageData:getHeight()
				)
			end

			-- Collect all glyphs.
			local textCps = (rbmfFile.useTextFiles and rbmfFile.textCodepoints or nil)

			for row, cpsOnRow in pairs(rbmfFile.codepoints) do -- @Robustness: Is the output stable if we use pairs() here?
				local x           = 1
				local y           = 1 + (row-1) * in_lineDist
				local glyphStartX = x

				for i, cp in ipairs(cpsOnRow) do
					local xNext = -1

					for x = x, in_imageData:getWidth()-1 do
						!GET_PIXEL(`in_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

						if r == sepR and g == sepG and b == sepB and a == sepA then
							xNext = x
							break
						end
					end

					if xNext < 0 then
						errorLine(
							"%s: Missing glyphs on row %d. (Expected %d, found %d)",
							imageFilename, row, #cpsOnRow, i-1
						)
					end

					x = xNext

					if not (textCps and not textCps[cp]) then
						local glyphInfo = {cp=cp, inX1=glyphStartX, inY1=y, inX2=x-1, inY2=y+in_lineDist-2, inW=x-glyphStartX, inH=in_lineHeight}
						table.insert(glyphs, glyphInfo)
					end

					x           = x + 1
					glyphStartX = x
				end
			end
		end

		----------------

		if not glyphs[1] then
			fileError(rbmfFile, "No glyphs to export.")
		end

		table.sort(glyphs, function(a, b)
			return a.cp < b.cp
		end)

		--
		-- Edit input image
		--
		if rbmfFile.editAlphaThreshold > 0 then
			-- Need to @Revise all this! 2021-03-21
			local function applyAlphaThreshold(x,y, r,g,b,a)
				return r, g, b, (a >= rbmfFile.editAlphaThreshold and 1 or 0)
			end

			for _, glyphInfo in ipairs(glyphs) do
				local outerX1, outerX2, outerY1, outerY2 = getImageContentBounds(in_imageData, glyphInfo.inX1, glyphInfo.inY1, glyphInfo.inX2, glyphInfo.inY2, .0001)
				-- local outerX1, outerX2, outerY1, outerY2 = getImageContentBounds(in_imageData, glyphInfo.inX1, glyphInfo.inY1, glyphInfo.inX2, glyphInfo.inY2, 1) -- This doesn't seem right?

				if outerX1 then
					--[[ Nah, this all messes stuff up.
					local innerX1, innerX2, innerY1, innerY2 = getImageContentBounds(in_imageData, outerX1, outerY1, outerX2, outerY2, 1/128)
					if not innerX1 then
						innerX1, innerX2, innerY1, innerY2 = outerX1, outerX2, outerY1, outerY2
					end

					print("measure pre ", glyphInfo.cp, glyphInfo.inX2-glyphInfo.inX1)
					glyphInfo.inX1 = glyphInfo.inX1 + innerX1 - outerX1
					glyphInfo.inX2 = glyphInfo.inX2 + innerX2 - outerX2
					glyphInfo.inW  = glyphInfo.inX2 - glyphInfo.inX1 + 1
					print("measure post", glyphInfo.cp, glyphInfo.inX2-glyphInfo.inX1)
					--]]

					in_imageData:mapPixel(applyAlphaThreshold, outerX1,outerY1, outerX2-outerX1+1,outerY2-outerY1+1) -- @Speed
				end
			end
		end

		--
		-- Write output images and descriptors
		--
		for _, outDescr in ipairs(rbmfFile.outputDescriptors) do
			-- @Feature: Automatic kerning calculations?

			outDescr.couldPack = not (rbmfFile.isColored or outDescr.outlineWidth > 0)
			outDescr.pack      = false--outDescr.couldPack -- LÖVE does not seem to support packing yet as of 11.3.

			-- Figure out how big the output image should be and the position of the glyphs.
			local out_imageWidth  = 0
			local out_imageHeight = 0

			do
				local x  = outDescr.imagePaddingH
				local y  = outDescr.imagePaddingV
				local xs = {x, x, x, x}
				local ys = {y, y, y, y}

				local function isPositionEarlier(x1,y1, x2,y2)
					if y1 < y2 then  return true  end
					return (x1 < x2)
				end

				for _, glyphInfo in ipairs(glyphs) do
					local wPadded = glyphInfo.inW + 2*outDescr.outlineWidth + outDescr.glyphPaddingL + outDescr.glyphPaddingR
					local hPadded = glyphInfo.inH + 2*outDescr.outlineWidth + outDescr.glyphPaddingU + outDescr.glyphPaddingD

					local channel = 1

					if outDescr.pack then
						if isPositionEarlier(xs[2],ys[2], xs[channel],ys[channel]) then  channel = 2  end
						if isPositionEarlier(xs[3],ys[3], xs[channel],ys[channel]) then  channel = 3  end
						if isPositionEarlier(xs[4],ys[4], xs[channel],ys[channel]) then  channel = 4  end
					end

					if xs[channel]+wPadded-1 > out_imageMaxSize-outDescr.imagePaddingH then -- @Incomplete: Enforce out_imageMaxSize on the height as well.
						xs[channel] = outDescr.imagePaddingH
						ys[channel] = ys[channel] + hPadded + outDescr.glyphSpacingV
					end

					glyphInfo.outChannel = channel

					glyphInfo.outW = wPadded
					glyphInfo.outH = hPadded
					glyphInfo.outX = xs[channel]
					glyphInfo.outY = ys[channel]

					out_imageWidth  = math.max(out_imageWidth,  xs[channel]+wPadded)
					out_imageHeight = math.max(out_imageHeight, ys[channel]+hPadded)

					xs[channel] = xs[channel] + wPadded + outDescr.glyphSpacingH
				end

				out_imageWidth  = out_imageWidth  + outDescr.imagePaddingH
				out_imageHeight = out_imageHeight + outDescr.imagePaddingV

				assert(out_imageWidth  > 0)
				assert(out_imageHeight > 0)

				-- Even numbers are safer than odd, yo.
				out_imageWidth  = math.ceil(out_imageWidth  / 2) * 2
				out_imageHeight = math.ceil(out_imageHeight / 2) * 2
			end

			local out_imageData        = LI.newImageData(out_imageWidth, out_imageHeight)
			local out_descriptorBuffer = {}

			table.insert(out_descriptorBuffer, F(
				'info face="" size=%d bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=0 aa=0 padding=%d,%d,%d,%d spacing=%d,%d outline=%d',
				in_lineHeight, -- size
				outDescr.glyphPaddingU, outDescr.glyphPaddingR, outDescr.glyphPaddingD, outDescr.glyphPaddingL, -- padding
				outDescr.glyphSpacingH, outDescr.glyphSpacingV, -- spacing
				outDescr.outlineWidth -- outline
			))
			for _, k in ipairs(outDescr.customValues) do
				local v = outDescr.customValues[k]
				table.insert(out_descriptorBuffer, F(" CUSTOM_%s=", k))
				table.insert(out_descriptorBuffer, v:find"^%-?%d*%.?%d+$" and v or F('"%s"', v))
			end
			table.insert(out_descriptorBuffer, "\n")

			table.insert(out_descriptorBuffer, F(
				-- @Incomplete: Support multiple pages when needed for big font sizes.
				'common lineHeight=%d base=%d scaleW=%d scaleH=%d pages=1 packed=%d alphaChnl=0 redChnl=0 greenChnl=0 blueChnl=0\n',
				in_lineHeight, -- lineHeight
				in_lineHeight, -- base
				out_imageWidth, out_imageHeight, -- scaleW, scaleH
				(outDescr.pack and 1 or 0) -- packed
			))

			table.insert(out_descriptorBuffer, F('page id=0 file="%s"\n', outDescr.filenameImage))

			-- Write glyphs.
			table.insert(out_descriptorBuffer, F('chars count=%d\n', #glyphs))

			-- out_imageData:mapPixel(function(x,y, r,g,b,a)  return 1, 0, 0, 1  end) -- DEBUG: Show areas we don't paste glyphs in.

			if outDescr.pack then
				!GET_IMAGE_DATA_POINTER `in_imageData`
				!GET_IMAGE_DATA_POINTER `out_imageData`

				for _, glyphInfo in ipairs(glyphs) do
					local outX1 = glyphInfo.outX + outDescr.glyphPaddingL -- Note: Packed glyphs have no outlines.
					local outY1 = glyphInfo.outY + outDescr.glyphPaddingU
					local outX2 = outX1 + glyphInfo.inW - 1
					local outY2 = outY1 + glyphInfo.inH - 1

					local dx = glyphInfo.inX1 - outX1
					local dy = glyphInfo.inY1 - outY1

					if glyphInfo.outChannel == 1 then
						for outY = outY1, outY2 do
							for outX = outX1, outX2 do
								!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
								!SET_PIXEL(`out_imageData`, `outX`,`outY`, `a`,nil,nil,nil)
							end
						end
					elseif glyphInfo.outChannel == 2 then
						for outY = outY1, outY2 do
							for outX = outX1, outX2 do
								!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
								!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,`a`,nil,nil)
							end
						end
					elseif glyphInfo.outChannel == 3 then
						for outY = outY1, outY2 do
							for outX = outX1, outX2 do
								!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
								!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,nil,`a`,nil)
							end
						end
					else--if glyphInfo.outChannel == 4 then
						for outY = outY1, outY2 do
							for outX = outX1, outX2 do
								!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
								!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,nil,nil,`a`)
							end
						end
					end
				end

			else
				for _, glyphInfo in ipairs(glyphs) do
					out_imageData:paste(
						in_imageData,
						glyphInfo.outX + outDescr.glyphPaddingL + outDescr.outlineWidth, -- dx
						glyphInfo.outY + outDescr.glyphPaddingU + outDescr.outlineWidth, -- dy
						glyphInfo.inX1, -- sx
						glyphInfo.inY1, -- sy
						glyphInfo.inW,  -- sw
						glyphInfo.inH   -- sh
					)
				end

				if outDescr.couldPack then
					!GET_IMAGE_DATA_POINTER `out_imageData`

					!MAP_PIXEL(`out_imageData`, `x`,`y`)
						!GET_PIXEL(`out_imageData`, nil,nil,nil,`a`, `x`,`y`)
						!SET_PIXEL(`out_imageData`, `x`,`y`, 1,1,1,`a`)
					!MAP_PIXEL_END()
				end
			end

			-- out_imageData:mapPixel(function(x,y, r,g,b,a)  return r, g, b, 1  end) -- DEBUG: Show as fully opaque / discard (glyphs in) alpha channel.

			for _, glyphInfo in ipairs(glyphs) do
				-- Note that the outlines will overlap when text is rendered.  @Incomplete: This should probably be a setting.
				table.insert(out_descriptorBuffer, F(
					'char id=%d x=%d y=%d width=%d height=%d xoffset=0 yoffset=0 xadvance=%d page=0 chnl=%d\n',
					glyphInfo.cp, -- id
					glyphInfo.outX, glyphInfo.outY, -- x, y
					glyphInfo.outW, glyphInfo.outH, -- width, height
					glyphInfo.inW + outDescr.glyphSpacingH, -- xadvance
					(outDescr.pack and 2^(glyphInfo.outChannel-1) or 15) -- chnl
				))
			end

			-- Add glyph outlines.
			if outDescr.outlineWidth > 0 then
				assert(not outDescr.pack)

				local w, h              = out_imageData:getDimensions()
				local readonlyImageData = LI.newImageData(w, h)

				local outlineWidth                           = outDescr.outlineWidth
				local outlineWidthSq                         = outlineWidth^2
				local outlineR, outlineG, outlineB, outlineA = unpack(outDescr.outlineColor)

				readonlyImageData:paste(out_imageData, 0,0, 0,0, w,h)

				!GET_IMAGE_DATA_POINTER `out_imageData`
				!GET_IMAGE_DATA_POINTER `readonlyImageData`

				local min = math.min
				local max = math.max

				if outlineWidth == 1 then
					!MAP_PIXEL(`out_imageData`, `x`,`y`)
						!(
						GET_PIXEL(`out_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`au`,  `    x        `,`max(y-1, 0  )`)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`aur`, `min(x+1, w-1)`,`max(y-1, 0  )`)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`ar`,  `min(x+1, w-1)`,`    y        `)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`adr`, `min(x+1, w-1)`,`min(y+1, h-1)`)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`ad`,  `    x        `,`min(y+1, h-1)`)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`adl`, `max(x-1, 0  )`,`min(y+1, h-1)`)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`al`,  `max(x-1, 0  )`,`    y        `)
						GET_PIXEL(`readonlyImageData`, nil,nil,nil,`aul`, `max(x-1, 0  )`,`max(y-1, 0  )`)

						local DIAGONAL_SIGNIFICANCE = .4
						)

						local neighborAlpha = max(
							au,
							aur * !(DIAGONAL_SIGNIFICANCE),
							ar,
							adr * !(DIAGONAL_SIGNIFICANCE),
							ad,
							adl * !(DIAGONAL_SIGNIFICANCE),
							al,
							aul * !(DIAGONAL_SIGNIFICANCE),
							a
						)

						r = r*a + (1-a)*outlineR
						g = g*a + (1-a)*outlineG
						b = b*a + (1-a)*outlineB
						a = a   + (1-a)*outlineA*neighborAlpha

						!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,`a`, true)
						-- !SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,`a`, true) -- DEBUG: Show result in mono-color.
						-- if neighborAlpha == 0 then  !(do SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,1, true) end)  end -- DEBUG: Show unaffected pixels.
					!MAP_PIXEL_END()

				else--if outlineWidth > 1 then -- @Incomplete: Add a setting that forces this method.
					--
					-- This doesn't look very good for partially diagonal lines in fonts with smooth
					-- edges/half-transparent pixels, but there's only so much that can be done when
					-- all we have are pixels. Maybe we can do something better for TrueType fonts?
					--
					!MAP_PIXEL(`out_imageData`, `x`,`y`)
						---------------------
						!GET_PIXEL(`out_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

						local neighborAlpha = a

						for circleY = max(y-outlineWidth, 0), min(y+outlineWidth, h-1) do
							for circleX = max(x-outlineWidth, 0), min(x+outlineWidth, w-1) do
								local distSq = (circleX-x)*(circleX-x) + (circleY-y)*(circleY-y)

								-- if distSq <= outlineWidthSq then
									!GET_PIXEL(`readonlyImageData`, nil,nil,nil,`circleA`, `circleX`,`circleY`)

									-- This doesn't look good in some cases if there are full shapes with half-
									-- transparent pixels (generally if the font is a bit too thin in places).
									-- We use the next piece of code instead!
									-- neighborAlpha = max(neighborAlpha, circleA*min(max(outlineWidth-distSq^.5, 0), 1))

									if circleA > .4 then -- @Hardcoded alpha threshold. (How does e.g. Photoshop create outline effects on layers? I think they use a threshold similar to this.)
										neighborAlpha = max(neighborAlpha, min(outlineWidth-distSq^.5+1, 1)) -- (Why is +1 needed here for the result to be correct?)

										-- Maybe something like this would be better than the above? Also, maybe we should
										-- support float widths for outlines? That would achieve the same effect I think.
										-- neighborAlpha = max(neighborAlpha, min(max(outlineWidth-distSq^.5-.3, 0), 1))
									end
								-- end
							end
						end

						r = r*a + (1-a)*outlineR
						g = g*a + (1-a)*outlineG
						b = b*a + (1-a)*outlineB
						a = a   + (1-a)*outlineA*neighborAlpha

						!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,`a`, true)
						-- !SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,`a`, true) -- DEBUG: Show result in mono-color.
						-- if neighborAlpha == 0 then  !(do SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,1, true) end)  end -- DEBUG: Show unaffected pixels.
					!MAP_PIXEL_END()
				end
			end

			-- Try to ensure linear interpolation will work properly when rendering in-game.  @Incomplete: Maybe there should be a setting to skip this step if it's not of importance.
			if not outDescr.couldPack and outDescr.outlineWidth == 0 then
				local w, h = out_imageData:getDimensions()

				!GET_IMAGE_DATA_POINTER `out_imageData`

				local min = math.min
				local max = math.max

				!MAP_PIXEL(`out_imageData`, `x`,`y`)
					!GET_PIXEL(`out_imageData`, nil,nil,nil,`a`, `x`,`y`)

					if a == 0 then
						!(
						-- Note: We don't need to use a readonlyImageData as we only write to transparent
						-- pixels and we only read/use values from non-transparent pixels.
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a1`, `    x        `,`max(y-1, 0  )`)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a2`, `min(x+1, w-1)`,`max(y-1, 0  )`)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a3`, `min(x+1, w-1)`,`    y        `)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a4`, `min(x+1, w-1)`,`min(y+1, h-1)`)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a5`, `    x        `,`min(y+1, h-1)`)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a6`, `max(x-1, 0  )`,`min(y+1, h-1)`)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a7`, `max(x-1, 0  )`,`    y        `)
						GET_PIXEL(`out_imageData`, nil,nil,nil,`a8`, `max(x-1, 0  )`,`max(y-1, 0  )`)
						)

						local weightInverted = 1 / (a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8)

						if weightInverted < 1/0 then
							!(
							-- Note: We don't need to use a readonlyImageData as we only write to transparent
							-- pixels and we only read/use values from non-transparent pixels.
							GET_PIXEL(`out_imageData`, `r1`,`g1`,`b1`,nil, `    x        `,`max(y-1, 0  )`)
							GET_PIXEL(`out_imageData`, `r2`,`g2`,`b2`,nil, `min(x+1, w-1)`,`max(y-1, 0  )`)
							GET_PIXEL(`out_imageData`, `r3`,`g3`,`b3`,nil, `min(x+1, w-1)`,`    y        `)
							GET_PIXEL(`out_imageData`, `r4`,`g4`,`b4`,nil, `min(x+1, w-1)`,`min(y+1, h-1)`)
							GET_PIXEL(`out_imageData`, `r5`,`g5`,`b5`,nil, `    x        `,`min(y+1, h-1)`)
							GET_PIXEL(`out_imageData`, `r6`,`g6`,`b6`,nil, `max(x-1, 0  )`,`min(y+1, h-1)`)
							GET_PIXEL(`out_imageData`, `r7`,`g7`,`b7`,nil, `max(x-1, 0  )`,`    y        `)
							GET_PIXEL(`out_imageData`, `r8`,`g8`,`b8`,nil, `max(x-1, 0  )`,`max(y-1, 0  )`)
							)

							local r = (r1*a1 + r2*a2 + r3*a3 + r4*a4 + r5*a5 + r6*a6 + r7*a7 + r8*a8) * weightInverted
							local g = (g1*a1 + g2*a2 + g3*a3 + g4*a4 + g5*a5 + g6*a6 + g7*a7 + g8*a8) * weightInverted
							local b = (b1*a1 + b2*a2 + b3*a3 + b4*a4 + b5*a5 + b6*a6 + b7*a7 + b8*a8) * weightInverted

							!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,`a`)

						else
							!SET_PIXEL(`out_imageData`, `x`,`y`, 0,0,0,`a`) -- Stomp unimportant pixels for hopefully better PNG compression.
						end
					end
				!MAP_PIXEL_END()
			end

			-- out_imageData:mapPixel(function(x,y, r,g,b,a)  return r, g, b, 1  end) -- DEBUG: Show as fully opaque.

			-- Write kernings.
			local kerningPairs = {}

			for pair in pairs(rbmfFile.kernings) do
				table.insert(kerningPairs, pair)
			end

			if kerningPairs[1] then
				table.sort(kerningPairs)

				table.insert(out_descriptorBuffer, F('kernings count=%d\n', #kerningPairs))

				for _, pair in ipairs(kerningPairs) do
					local first, second = pair:match(F("(%s)(%s)", utf8.charpattern, utf8.charpattern))
					first               = utf8.codepoint(first)
					second              = utf8.codepoint(second)

					local offset = rbmfFile.kernings[pair]

					table.insert(out_descriptorBuffer, F('kerning first=%d second=%d amount=%d\n', first, second, offset))
				end
			end

			-- Save files.
			local baseDir = (out_directory ~= "" and out_directory or Path("..", rbmfFile.path):getDirectory())

			if outDescr.filenameImage ~= "" then
				local pathObj       = Path(outDescr.filenameImage, baseDir)
				local dir, filename = pathObj:getDirectoryAndFilename()

				printf("Writing image: %s", pathObj:toString())

				if not connectToDirectory(dir) then
					errorLine("Could not access directory '%s'.", dir)
				end

				local ok, err = out_imageData:encode("png", filename)
				if not ok then
					errorLine("Could not write font image '%s'. (%s)", pathObj:toString(), err)
				end
			end

			if outDescr.filenameDescriptor ~= "" then
				local pathObj       = Path(outDescr.filenameDescriptor, baseDir)
				local dir, filename = pathObj:getDirectoryAndFilename()

				printf("Writing descriptor: %s", pathObj:toString())

				if not connectToDirectory(dir) then
					errorLine("Could not access directory '%s'.", dir)
				end

				local ok, err = LF.write(filename, table.concat(out_descriptorBuffer))
				if not ok then
					errorLine("Could not write font descriptor '%s'. (%s)", pathObj:toString(), err)
				end
			end
		end--for rbmfFile.outputDescriptors
	end--for rbmfFiles

	--
	-- Write icons file
	--
	if out_iconsPath ~= "" then
		local icons = getIcons()

		-- Should we always write the icons file? (This is probably never an
		-- issue as it seems unlikely that someone will define icons at some
		-- point but later change their mind and remove them all, thus leaving
		-- this file with garbage in it.)
		if icons[1] then
			local buffer = {}

			for _, icon in ipairs(icons) do
				local cp = getIconCodepoint(icon)
				table.insert(buffer, F("%d %s\n", cp, icon))
			end

			local pathObj       = Path(out_iconsPath)
			local dir, filename = pathObj:getDirectoryAndFilename()

			printf("Writing icons file: %s", pathObj:toString())

			if not connectToDirectory(dir) then
				errorLine("Could not access directory '%s'.", dir)
			end

			local ok, err = LF.write(filename, table.concat(buffer))
			if not ok then
				errorLine("Could not write icons file '%s'. (%s)", pathObj:toString(), err)
			end
		end
	end

	--
	-- All done!
	--
	local endTime = socket.gettime()

	print!(CMD_SEPARATOR)
	if warningCount > 0 then
		printf("Completed with %d warning%s!", warningCount, S(warningCount))
	else
		print("Completed successfully!")
	end
	printf("Time:  %.3f seconds", endTime-startTime)
	printf("Icons: %d", getIconCount())
	print!(CMD_SEPARATOR)
	print()

	return function()
		-- return 0 -- This sometimes crashes us for some reason. Is there a race condition somewhere or something? Who the hell knows, so we do the following instead...
		os.exit(0)
	end
end



!else--if TEST then

function love.load()
	-- love.graphics.setDefaultFilter("nearest")

	local path = "temp/smallPixel.bmfont"
	-- local path = "temp/smallPixel_outline.bmfont"
	-- local path = "temp/vector.bmfont"
	-- local path = "temp/vector_outline.bmfont"
	_G.font = love.graphics.newFont(path)

	_G.icons = {}

	for line in love.filesystem.lines("temp/.fonticons") do
		local cp, name = line:match"(%d+) (%S+)"
		icons[name]    = require"utf8".char(tonumber(cp))
	end

	_G.text = ("Hello, world!\nPress {psx} to begin"):gsub("{(%w+)}", icons)
end

function love.keypressed(key)
	if key == "escape" then
		love.event.quit()
	end
end

function love.draw()
	love.graphics.clear(.25, .25, .25, 1)
	love.graphics.setFont(font)
	love.graphics.scale(4)
	love.graphics.print(text, 5, 5)
end

!end


