--[[============================================================
--=
--=  ReFreezed Bitmap Font converter - convert RBMF files to BMFont
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Works with LÖVE 11.3
--=
--============================================================]]

!if not TEST then

local CMD_HELP = [=[
	$ RbmfConverter.exe inputPath1 [inputPath2 ...] [options]

	Options:
		--outdir   <directory>  # Where to output files. (Default: Same directory as the input.)
		--maxsize  <size>       # Maximum output image size in pixels. (Default: 2048)
		--icons    <filePath>   # Where to write the icons file if any icons are specified. (Default: <outputDirectory>/.fonticons)
		--mergeicons            # Merge new icons with existing icons if the icons file exists. (Default: File is replaced.)
		--missing  <filePath>   # File to write characters that are missing from at least one font. (Default: No file is written.)
		--mergemissing          # Merge missing characters with existing characters if the missing file exists. (Default: File is replaced.)
		--textfile <filePath1> [--textfile <filePath2> ...]  # Files containing characters to rasterize when using vector fonts.

	Notes:
		<inputPath> can be a .rbmf file or a directory with .rbmf files.
		The filenames of outputted files is specified in the font descriptor.
		Relative --textfile paths will be relative to CWD, unlike the 'textFile' input parameter in the descriptor.
]=]

!local CMD_TITLE     = "ReFreezed Bitmap Font converter "..getReleaseVersion()
!local CMD_SEPARATOR = string.rep("-", #CMD_TITLE)

local programArguments = arg



local function RbmfFile()
	return {
		path = "",
		ln   = 0, -- Current line number.

		-- Params.
		version = 0,

		codepoints = {--[[ [row1]={cp1,...}, ... ]]},
		icons      = {--[[ iconName1,        ... ]]},

		isColored = true, -- Uncolored fonts can be optimized so the 4 channels contain different glyphs in the output.

		fontFilename = "",
		fontSize     = 0,
		fontHinting  = "normal", -- "normal"|"light"|"mono"|"none"

		textFilePaths = {--[[ path1, ... ]]},

		editAlphaThreshold = 0, -- 0 means we don't do this edit.
		editTrimGlyphs     = true,

		outputDescriptors = {--[[ outputDescriptor1, ... ]]},

		kernings = {--[[ [pair1]=offset1, ... ]]},
		--

		codepointLines = {--[[ [cp1]=ln1,   ... ]]}, -- For dupe checking.
		kerningLines   = {--[[ [pair1]=ln1, ... ]]}, -- For dupe checking.
		lastRow        = 0,

		useTextFiles   = false,
		textCodepoints = {--[[ [cp1]=true, ... ]]},

		outDirectory = "",

		missingCodepoints = {--[[ cp1, ... ]]},
	}
end

local function OutputDescriptor()
	return {
		ln = 0,

		-- Params.
		filenameImage      = "",
		filenameDescriptor = "",

		glyphColor = {1,1,1,1},

		glyphPaddingU = 0,
		glyphPaddingR = 0,
		glyphPaddingD = 0,
		glyphPaddingL = 0,

		glyphSpacingH = 0,
		glyphSpacingV = 0,

		imagePaddingH = 0,
		imagePaddingV = 0,

		outlineWidth  = 0,
		outlineColor  = {0,0,0,1},
		outlineMethod = "auto", -- "auto"|"basic"

		renderSpacing = 1,

		paddingAffectsRenderSpacing = false,
		outlineAffectsRenderSpacing = false,

		imageBounds   = "smallest", -- "smallest"|"poweroftwo"|"poweroftwosquare"
		imageEncoding = "png",      -- "png"|"tga"

		alignForMipmapLevels = 1, -- Includes the original unresized image.

		customValues = {--[[ [1]=k1, [k1]=v1, ... ]]},
		--

		paramLines = {},

		pathImage      = "",
		pathDescriptor = "",

		couldPack = false,
		pack      = false,

		mipmapAlignment = 1, -- 2 ^ (alignForMipmapLevels - 1)
	}
end

local function GlyphInfo(cp)
	return {
		cp = cp,

		inX1 = 0, -- These may get trimmed.
		inY1 = 0,
		inX2 = 0,
		inY2 = 0,

		inW = 0, -- inX2 - inX1 + 1
		inH = 0, -- inY2 - inY1 + 1

		inW0 = 0, -- Untrimmed width.

		inOffsetX = 0, -- How much was trimmed on the left.
		inOffsetY = 0, -- How much was trimmed on the top.

		outW = 0,
		outH = 0,

		outImageIndex = 1,
		outChannel    = 1, -- Ignored if not packing.
		outX          = 0,
		outY          = 0,
	}
end



function love.errorhandler(err)
	io.stderr:write(debug.traceback("ERROR(internal): "..tostring(err), 3), "\n\n")
end
love.errhand = nil



function love.run()
	local startTime = require"socket".gettime()

	package.path = "?.lua;srcgen/?.lua"
	love.filesystem.setRequirePath(package.path)

	_G.Path   = require"path"
	_G.physfs = require"physfs"
	_G.socket = require"socket"
	_G.utf8   = require"utf8"

	require"functions"

	_G.LF = love.filesystem
	_G.LI = love.image

	_G.warningCount = 0

	io.stdout:setvbuf"no"
	io.stderr:setvbuf"no"

	--
	-- Get args
	--

	local in_paths           = {}
	local in_textFilesForAll = {}
	local out_directory      = ""
	local out_imageMaxSize   = 2048
	local out_iconsPath      = ""
	local out_mergeIcons     = false
	local out_missingPath    = ""
	local out_mergeMissing   = false

	local args = love.arg.parseGameArguments(programArguments)
	local i    = 1

	args[1] = args[1] or "--help"

	while args[i] do
		if args[i] == "--help" or args[i] == "-help" or args[i] == "-?" or args[i]:find"^/[Hh][Ee][Ll][Pp]$" or args[i] == "/?" then
			print!(CMD_TITLE)
			print()
			print((CMD_HELP:gsub("\t", "    ")))
			return

		elseif not args[i]:find"^%-" then
			table.insert(in_paths, normalizePath(args[i])) -- Directory or file.
			i = i+1

		elseif args[i] == "--outdir" then
			out_directory = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			out_directory = normalizePath(out_directory)
			i = i+2

		elseif args[i] == "--maxsize" then
			local v          = args[i+1] or errorLine("Argument: Missing number after '%s'.", args[i])
			out_imageMaxSize = tonumber(v:match"^%d+$") or errorLine("Argument: '%s' is not an unsigned integer.", v)
			if out_imageMaxSize < 1 then
				errorLine("--maxsize must be positive.")
			end
			i = i+2

		elseif args[i] == "--icons" then
			out_iconsPath = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			out_iconsPath = normalizePath(out_iconsPath)
			i = i+2

		elseif args[i] == "--mergeicons" then
			out_mergeIcons = true
			i = i+1

		elseif args[i] == "--missing" then
			out_missingPath = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			out_missingPath = normalizePath(out_missingPath)
			i = i+2

		elseif args[i] == "--mergemissing" then
			out_mergeMissing = true
			i = i+1

		elseif args[i] == "--textfile" then
			local path = args[i+1] or errorLine("Argument: Missing path after '%s'.", args[i])
			table.insert(in_textFilesForAll, normalizePath(path))
			i = i+2

		elseif args[i] == "--nogc" then
			collectgarbage("stop")
			i = i+1

		else
			errorLine("Argument: Unknown option '%s'.", args[i])
		end
	end

	if not in_paths[1] then
		errorLine("Argument: Missing any input path.") -- @UX: Show help.
	end

	print!(CMD_TITLE)
	print!(CMD_SEPARATOR)
	print(os.date"         %Y-%m-%d %H:%M:%S")
	printf(      "  Input: %s", table.concat(in_paths, ", "))
	printf(      " Output: %s", (out_directory ~= "" and out_directory or "(in input directory)"))
	printf(      "MaxSize: %dx%d", out_imageMaxSize, out_imageMaxSize)
	print!(CMD_SEPARATOR)

	local iconImageData = LI.newImageData("gfx/appIcon16.png") -- We do this before we start tinkering with PhysFS.

	-- Collect all paths to process.
	local rbmfFiles = {}

	for _, path in ipairs(in_paths) do
		if isFile(path) then
			local rbmfFile = RbmfFile()
			rbmfFile.path  = path
			table.insert(rbmfFiles, rbmfFile)

		elseif isDirectory(path) then
			for _, filename in ipairs(getDirectoryItems(path)) do
				if filename:find"%.rbmf$" then
					local rbmfFile = RbmfFile()
					rbmfFile.path  = path.."/"..filename
					table.insert(rbmfFiles, rbmfFile)
				end
			end

		else
			errorLine("'%s' is not an accessible file nor directory.", path)
		end
	end

	--
	-- Load existing icons
	--
	if out_iconsPath == "" and out_directory ~= "" then
		out_iconsPath = Path(".fonticons", out_directory):toString()
	end

	if out_mergeIcons and out_iconsPath ~= "" and isFile(out_iconsPath) then
		for ln, line in eachLine(out_iconsPath) do
			local cp, icon = line:match"^ *(%d+) +(%S+) *$"
			cp             = tonumber(cp)

			if not cp then  errorLine("%s:%d: Bad line format: %s", out_iconsPath, ln, line)  end

			setIconCodepoint(icon, cp)
		end
	end

	--
	-- Read rbmf files
	--
	for _, rbmfFile in ipairs(rbmfFiles) do
		if rbmfFile.path == "" then
			errorLine("An input path is empty.")
		end

		printf("Loading RBMF: %s", rbmfFile.path)
		reservePathForReading(rbmfFile.path, "RBMF descriptor")

		local section         = ""
		local sectionLines    = {}
		local currentOutDescr = nil
		local paramLines      = {}

		for ln, line in eachLine(rbmfFile.path) do
			rbmfFile.ln = ln
			local k, v  = line:match"^([%a][%w_.]+)=(.*)$"

			-- Empty/comment.
			if line == "" or line:find"^#" then
				-- void

			-- Version line.
			elseif rbmfFile.version == 0 then
				if k ~= "version" then
					fileError(rbmfFile, "The first line must be the file version number!")
				end

				rbmfFile.version = fileAssert(rbmfFile, parseUint(v))
				if rbmfFile.version ~= 1 then
					fileError(rbmfFile, "Unsupported file version '%d'.", rbmfFile.version)
				end

			-- Section start.
			elseif line:find"^%[" then
				section = line:match"%[(%w+)%]$" or fileError(rbmfFile, "Invalid section name line format: %s", line)

				if sectionLines[section] and not (section == "out") then
					fileError(rbmfFile, "Duplicate section '%s'. (Previous is on line %d)", section, sectionLines[section])
				end
				sectionLines[section] = ln

				if section == "out" then
					currentOutDescr    = OutputDescriptor()
					currentOutDescr.ln = ln
					paramLines         = currentOutDescr.paramLines
					table.insert(rbmfFile.outputDescriptors, currentOutDescr)
				else
					currentOutDescr    = nil
					paramLines         = {}
				end

				if section:find"^%d+$" then
					rbmfFile.lastRow = math.max(rbmfFile.lastRow, tonumber(section))
				end

			elseif not k then
				fileError(rbmfFile, "Invalid key-value line format: %s", line)

			----------------------------------------------------------------

			elseif section == "in" then
				if paramLines[k] and not (k == "textFile") then
					fileError(rbmfFile, "Duplicate parameter '%s'. (Previous is on line %d)", k, paramLines[k])
				end
				paramLines[k] = ln

				v = trim(v)

				if k == "colored" then
					rbmfFile.isColored = fileAssert(rbmfFile, parseBool(v))

				elseif k == "fontFile" then
					rbmfFile.fontFilename = (v ~= "" and v or fileError(rbmfFile, "TrueType font path cannot be empty."))
				elseif k == "fontSize" then
					rbmfFile.fontSize = fileAssert(rbmfFile, parseUint(v))
					if rbmfFile.fontSize < 1 then
						fileError(rbmfFile, "TrueType font size must be positive. (Value is '%s')", v)
					end
				elseif k == "fontHinting" then
					rbmfFile.fontHinting = v
					if not (v == "normal" or v == "light" or v == "mono" or v == "none") then
						fileError(rbmfFile, "Invalid TrueType font hinting '%s'. (Valid values: normal, light, mono, none)", v)
					end

				elseif k == "textFile" then
					-- Note: Paths are relative to inputPath, unlike the --textfile argument.
					local path = (v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					table.insert(rbmfFile.textFilePaths, path)

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "edit" then
				if paramLines[k] then
					fileError(rbmfFile, "Duplicate parameter '%s'. (Previous is on line %d)", k, paramLines[k])
				end
				paramLines[k] = ln

				v = trim(v)

				if k == "alphaThreshold" then
					rbmfFile.editAlphaThreshold = fileAssert(rbmfFile, parseNumber(v))
					if rbmfFile.editAlphaThreshold < 0 or rbmfFile.editAlphaThreshold > 1 then
						fileError(rbmfFile, "Alpha threshold must be between 0 and 1. (Value is '%s')", v)
					end

				elseif k == "trim" then
					rbmfFile.editTrimGlyphs = fileAssert(rbmfFile, parseBool(v))

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "out" then
				if paramLines[k] then
					fileError(rbmfFile, "Duplicate parameter '%s'. (Previous is on line %d)", k, paramLines[k])
				end
				paramLines[k] = ln

				v = trim(v)

				if k == "fileImage" then
					local path                    = normalizePath(v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					currentOutDescr.filenameImage = processPathTemplate(rbmfFile, path)
				elseif k == "fileDescriptor" then
					local path                         = normalizePath(v ~= "" and v or fileError(rbmfFile, "Path cannot be empty."))
					currentOutDescr.filenameDescriptor = processPathTemplate(rbmfFile, path)

				elseif k == "glyphColor" then
					local c                = currentOutDescr.glyphColor
					c[1], c[2], c[3], c[4] = fileAssert(rbmfFile, parseColor(v))

				elseif k == "glyphPadding" then
					currentOutDescr.glyphPaddingU, currentOutDescr.glyphPaddingR, currentOutDescr.glyphPaddingD, currentOutDescr.glyphPaddingL = fileAssert(rbmfFile, parseUint4Sides(v))
				elseif k == "glyphSpacing" then
					currentOutDescr.glyphSpacingV, currentOutDescr.glyphSpacingH = fileAssert(rbmfFile, parseUint2Sides(v))

				elseif k == "imagePadding" then
					currentOutDescr.imagePaddingV, currentOutDescr.imagePaddingH = fileAssert(rbmfFile, parseUint2Sides(v))

				elseif k == "outlineWidth" then
					currentOutDescr.outlineWidth = fileAssert(rbmfFile, parseUint(v))
				elseif k == "outlineColor" then
					local c                = currentOutDescr.outlineColor
					c[1], c[2], c[3], c[4] = fileAssert(rbmfFile, parseColor(v))

				elseif k == "outlineMethod" then
					if not (v == "auto" or v == "basic") then
						fileError(rbmfFile, "Invalid outline method '%s'. (Valid values: auto, basic)", v)
					end
					currentOutDescr.outlineMethod = v

				elseif k == "renderSpacing" then
					currentOutDescr.renderSpacing = fileAssert(rbmfFile, parseInt(v))

				elseif k == "paddingAffectsRenderSpacing" then
					currentOutDescr.paddingAffectsRenderSpacing = fileAssert(rbmfFile, parseBool(v))
				elseif k == "outlineAffectsRenderSpacing" then
					currentOutDescr.outlineAffectsRenderSpacing = fileAssert(rbmfFile, parseBool(v))

				elseif k == "imageBounds" then
					if not (v == "smallest" or v == "poweroftwo" or v == "poweroftwosquare") then
						fileError(rbmfFile, "Invalid image shape '%s'. (Valid values: smallest, poweroftwo, poweroftwosquare)", v)
					end
					if v == "poweroftwo" or v == "poweroftwosquare" then
						local acceptedSize = 2 ^ math.ceil(math.log(out_imageMaxSize) / math.log(2))
						if out_imageMaxSize ~= acceptedSize then
							-- @UX: Automatically calculate the biggest power-of-two size that fits in out_imageMaxSize.
							fileError(rbmfFile, "Specified --maxsize must be power-of-two for '%s' to work. (It is %d)", v, out_imageMaxSize)
						end
					end
					currentOutDescr.imageBounds = v

				elseif k == "imageEncoding" then
					if not (v == "png" or v == "tga") then
						fileError(rbmfFile, "Invalid image encoding '%s'. (Valid values: png, tga)", v)
					end
					currentOutDescr.imageEncoding = v

				elseif k == "alignForMipmapLevels" then
					currentOutDescr.alignForMipmapLevels = fileAssert(rbmfFile, parseUint(v))
					if currentOutDescr.alignForMipmapLevels < 1 then
						fileError(rbmfFile, "There must be at least one level.")
					end

				elseif k:find"^custom%.[%a_][%w_]*$" then
					k = k:sub(8)

					if currentOutDescr.customValues[k] == nil then
						table.insert(currentOutDescr.customValues, k)
					end

					currentOutDescr.customValues[k] = v

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section:find"^%d+$" then
				-- if paramLines[k] and not (k == "glyphs" or k == "icons") then
				-- 	fileError(rbmfFile, "Duplicate parameter '%s'. (Previous is on line %d)", k, paramLines[k])
				-- end
				-- paramLines[k] = ln

				if k == "glyphs" then
					if v == "" then
						fileError(rbmfFile, "Missing characters.")
					end

					local row = tonumber(section)

					for _, cp in utf8.codes(v) do
						if rbmfFile.codepointLines[cp] == ln then
							fileError(rbmfFile, "Glyph '%s' (codepoint %d) appears multiple times on the line.", utf8.char(cp), cp)
						elseif rbmfFile.codepointLines[cp] then
							fileError(rbmfFile, "Glyph '%s' (codepoint %d) already appeared previously on line %d.", utf8.char(cp), cp, rbmfFile.codepointLines[cp])
						end

						addCodepoint(rbmfFile, row, cp, nil)
					end

				else
					v = trim(v)

					if v == "" then
						fileError(rbmfFile, "Missing icon names.")
					end

					if k == "icons" then
						local row = tonumber(section)

						for icon in v:gmatch"%S+" do
							local cp = getIconCodepoint(icon)

							if rbmfFile.codepointLines[cp] == ln then
								fileError(rbmfFile, "Icon '%s' appears multiples times on the line.", icon)
							elseif rbmfFile.codepointLines[cp] then
								fileError(rbmfFile, "Icon '%s' already appeared previously on line %d.", icon, rbmfFile.codepointLines[cp])
							end

							addCodepoint(rbmfFile, row, cp, icon)
						end

					else
						fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
					end
				end

			----------------------------------------------------------------

			elseif section == "kerning" then
				-- if paramLines[k] and not (k == "forward" or k == "bothways") then
				-- 	fileError(rbmfFile, "Duplicate parameter '%s'. (Previous is on line %d)", k, paramLines[k])
				-- end
				-- paramLines[k] = ln

				v = trim(v)

				if k == "forward" then
					local firsts, seconds, thirds, offset = v:match"^(%S+) +(%S+) +(%S+) +(%S+)$"
					if not firsts then
						firsts, seconds, offset = v:match"^(%S+) +(%S+) +(%S+)$"
					end
					if not firsts then
						fileError(rbmfFile, "Invalid 'forward' kerning value format '%s'. (Format is 'firstGlyphs secondGlyphs [thirdGlyphs] offset').", v)
					end

					offset = fileAssert(rbmfFile, parseInt(offset))

					addKerningPairs(rbmfFile, firsts, seconds, offset, false)
					if thirds then  addKerningPairs(rbmfFile, seconds, thirds, offset, false)  end

				elseif k == "bothways" then
					local firsts, seconds, offset = v:match"^(%S+) +(%S+) +(%S+)$"

					if not firsts then
						fileError(rbmfFile, "Invalid 'bothways' kerning value format '%s'. (Format is 'firstGlyphs secondGlyphs offset').", v)
					end

					offset = fileAssert(rbmfFile, parseInt(offset))

					addKerningPairs(rbmfFile, firsts, seconds, offset, true)

				else
					fileError(rbmfFile, "Unknown [%s] key '%s'.", section, k)
				end

			----------------------------------------------------------------

			elseif section == "" then
				fileError(rbmfFile, "Expected a section.")
			else
				rbmfFile.ln = sectionLines[section]
				fileError(rbmfFile, "Unknown section name '%s'.")
			end
		end--for eachLine(rbmfFile.path)
		rbmfFile.ln = 0

		-- Validate and set final values.
		if not rbmfFile.outputDescriptors[1] then
			fileWarning(rbmfFile, "No outputs specified.")
		end

		if rbmfFile.textFilePaths[1] and rbmfFile.fontFilename == "" then
			fileError(rbmfFile, "%d text files were specified, but no TrueType font.", #rbmfFile.textFilePaths)
		end

		if rbmfFile.fontFilename ~= "" and rbmfFile.fontSize == 0 then
			fileError(rbmfFile, "A TrueType font was specified, but no font size.")
		end
		if rbmfFile.fontSize > 0 and rbmfFile.fontFilename == "" then
			fileError(rbmfFile, "A font size was specified, but no TrueType font.")
		end

		rbmfFile.useTextFiles = (in_textFilesForAll[1] or rbmfFile.textFilePaths[1]) ~= nil
		if not rbmfFile.useTextFiles and rbmfFile.lastRow == 0 then
			fileError(rbmfFile, "No glyphs specified or imported from text files.")
		end

		rbmfFile.outDirectory = (out_directory ~= "" and out_directory or Path(rbmfFile.path):getDirectory())

		for _, outDescr in ipairs(rbmfFile.outputDescriptors) do
			if outDescr.filenameImage ~= "" then
				outDescr.pathImage = Path(outDescr.filenameImage, rbmfFile.outDirectory):toString()
			else
				rbmfFile.ln = outDescr.ln
				fileWarning(rbmfFile, "No image file specified for this output.")
				rbmfFile.ln = 0
			end

			if outDescr.filenameDescriptor ~= "" then
				outDescr.pathDescriptor = Path(outDescr.filenameDescriptor, rbmfFile.outDirectory):toString()
			else
				rbmfFile.ln = outDescr.ln
				fileWarning(rbmfFile, "No descriptor file specified for this output.")
				rbmfFile.ln = 0
			end

			if outDescr.alignForMipmapLevels > 1 then
				if outDescr.imagePaddingH+outDescr.imagePaddingH > 0 then
					rbmfFile.ln = math.max(outDescr.paramLines.alignForMipmapLevels, outDescr.paramLines.imagePadding)
					fileError(rbmfFile, "Cannot combine alignForMipmapLevels and imagePadding.")
				end
				if outDescr.glyphSpacingH+outDescr.glyphSpacingV > 0 then
					rbmfFile.ln = math.max(outDescr.paramLines.alignForMipmapLevels, outDescr.paramLines.glyphSpacing)
					fileError(rbmfFile, "Cannot combine alignForMipmapLevels and glyphSpacing.")
				end

				outDescr.mipmapAlignment = 2 ^ (outDescr.alignForMipmapLevels-1)
			end
		end
	end--for rbmfFiles

	--
	-- Load glyph filter text files
	--
	local function processTextFile(pathObj, textCpSet)
		printf("Loading text file: %s", pathObj:toString())

		local s, err = getFileContents(pathObj)
		if not s then
			errorLine("Could not open text file '%s'. (%s)", pathObj:toString(), err)
		end

		for _, cp in utf8.codes(s) do
			if cp >= 32 then  textCpSet[cp] = true  end -- @Robustness: Better printable character check.
		end
	end

	local textCodepointsForAll = {}
	for _, path in ipairs(in_textFilesForAll) do
		processTextFile(Path(path), textCodepointsForAll)
	end

	for _, rbmfFile in ipairs(rbmfFiles) do
		if rbmfFile.useTextFiles then
			for cp in pairs(textCodepointsForAll) do
				rbmfFile.textCodepoints[cp] = true
			end
			for _, path in ipairs(rbmfFile.textFilePaths) do
				processTextFile(Path(path, Path("..", rbmfFile.path)), rbmfFile.textCodepoints)
			end
		end
	end

	--
	-- Convert font files
	--
	for _, rbmfFile in ipairs(rbmfFiles) do
		--
		-- Load input image
		--
		local in_imageData
		local in_lineHeight, in_lineDist
		local glyphs = {}

		-- Vector font
		----------------------------------------------------------------

		if rbmfFile.fontFilename ~= "" then
			if not love.window then
				require"love.window"
				require"love.graphics"
				require"love.font"

				-- @UX: Can we make the window not grab focus somehow?
				love.window.setMode(1, 1, {borderless=true, vsync=false, x=0, y=0})
				love.window.setIcon(iconImageData)
				love.window.minimize()
			end

			local LG = love.graphics

			local pathObj = Path("..", rbmfFile.path)
			pathObj:append(rbmfFile.fontFilename)

			printf("Loading vector font: %s", pathObj:toString())
			reservePathForReading(pathObj:toString(), "input font for '%s'", rbmfFile.path)

			mustConnectToDirectory(pathObj:getDirectory())
			local font = LG.newFont(pathObj:getFilename(), rbmfFile.fontSize, rbmfFile.fontHinting)

			in_lineHeight = font:getHeight()
			in_lineDist   = in_lineHeight + 1

			-- Collect all glyphs. Note that we set the coords later.
			for cp in pairs(rbmfFile.textCodepoints) do -- Note: textCodepoints should be empty if useTextFiles is unset.
				if font:hasGlyphs(cp) then
					table.insert(glyphs, GlyphInfo(cp))
				else
					table.insert(rbmfFile.missingCodepoints, cp)
				end
			end

			for row, cpsOnRow in pairs(rbmfFile.codepoints) do
				for _, cp in ipairs(cpsOnRow) do
					if rbmfFile.textCodepoints[cp] then
						-- void
					elseif font:hasGlyphs(cp) then
						table.insert(glyphs, GlyphInfo(cp))
					else
						table.insert(rbmfFile.missingCodepoints, cp)
					end
				end
			end

			warnAboutAnyMissingCodepoints(rbmfFile.missingCodepoints, rbmfFile.fontFilename)

			if not glyphs[1] then
				fileError(rbmfFile, "No glyphs to export from fontFile '%s'.", rbmfFile.fontFilename)
			end

			-- Determine virtual input image size and glyph coords.
			local virtual_imageMaxSize = LG.getSystemLimits().texturesize
			local virtual_imageWidth   = 0
			local virtual_imageHeight  = 0
			local x1                   = 1/0
			local y1                   = -in_lineHeight

			for _, glyphInfo in ipairs(glyphs) do
				local c = utf8.char(glyphInfo.cp)
				local w = font:getWidth(c)

				if x1+w-1 > virtual_imageMaxSize then
					virtual_imageHeight = virtual_imageHeight + in_lineHeight -- @Robustness: Limit the height!
					x1                  = 0
					y1                  = y1 + in_lineHeight
				end

				local x2 = x1 + w - 1
				local y2 = y1 + in_lineHeight - 1

				glyphInfo.inX1 = x1
				glyphInfo.inX2 = x2
				glyphInfo.inY1 = y1
				glyphInfo.inY2 = y2
				glyphInfo.inW  = w
				glyphInfo.inH  = in_lineHeight
				glyphInfo.inW0 = glyphInfo.inW

				virtual_imageWidth = math.max(virtual_imageWidth, x2+1)
				x1                 = x2 + 1
			end

			assert(virtual_imageWidth  > 0)
			assert(virtual_imageHeight > 0)

			-- Create virtual input image.
			local fontCanvas = LG.newCanvas(virtual_imageWidth, virtual_imageHeight)

			LG.setCanvas(fontCanvas)
			LG.clear(0, 0, 0, 0)

			LG.setFont(font)
			LG.setColor(1, 1, 1)
			LG.setBlendMode("alpha", "premultiplied")
			for _, glyphInfo in ipairs(glyphs) do
				local c = utf8.char(glyphInfo.cp)
				LG.setScissor(glyphInfo.inX1, glyphInfo.inY1, glyphInfo.inW, glyphInfo.inH) -- @Bug: Bleeding may happen if fontHinting is 'none'. I wonder how to best fix this... 2021-03-31
				LG.print(c, glyphInfo.inX1, glyphInfo.inY1)
			end

			LG.setScissor()
			LG.setCanvas(nil)

			in_imageData = fontCanvas:newImageData()
			-- mustConnectToDirectory(LF.getSaveDirectory()) ; assert(in_imageData:encode("png", "virt_in_image.png")) -- DEBUG

			font:release()
			fontCanvas:release()

		-- Bitmap font
		----------------------------------------------------------------

		else--if rbmfFile.fontFilename == "" then
			local imagePathObj = Path(rbmfFile.path)
			local pathSegments = imagePathObj.path
			imagePathObj:setFilename(getLast(imagePathObj.path):gsub("%.%w+$", "")..".png")

			printf("Loading image: %s", imagePathObj:toString())
			reservePathForReading(imagePathObj:toString(), "input image for '%s'", rbmfFile.path)

			mustConnectToDirectory(imagePathObj:getDirectory())
			in_imageData = LI.newImageData(imagePathObj:getFilename())

			if in_imageData:getWidth() < 2 or in_imageData:getHeight() < 2 then
				errorLine("%s: Image is too small.", imagePathObj:getFilename())
			end

			-- Get separator line color.
			!GET_IMAGE_DATA_POINTER `in_imageData`
			!GET_PIXEL(`in_imageData`, `sepR`,`sepG`,`sepB`,`sepA`, 0,0)

			-- in_imageData:mapPixel(function()  return sepR,sepG,sepB,sepA  end, 1,0, 1,in_imageData:getHeight()) -- DEBUG: Test border that is multiple pixels thick.

			-- Look for top and left border.
			do
				!GET_PIXEL(`in_imageData`, `r1`,`g1`,`b1`,`a1`, 1,0)
				!GET_PIXEL(`in_imageData`, `r2`,`g2`,`b2`,`a2`, 0,1)

				if not (
					r1 == sepR and g1 == sepG and b1 == sepB and a1 == sepA and
					r2 == sepR and g2 == sepG and b2 == sepB and a2 == sepA
				) then
					errorLine("%s: Borders are incorrect.", imagePathObj:getFilename())
				end
			end

			-- Get line height and distance.
			-- LineDistance = SeparatorHeight + LineHeight
			in_lineDist = 0

			for y = 1, in_imageData:getHeight()-1 do
				!GET_PIXEL(`in_imageData`, `r`,`g`,`b`,`a`, 1,`y`)

				if r == sepR and g == sepG and b == sepB and a == sepA then
					in_lineDist = y
					break
				end
			end

			in_lineHeight = in_lineDist - 1

			if in_lineHeight < 1 then
				errorLine("%s: Something went wrong when calculating line height. Are borders surrounding the glyphs properly?", imagePathObj:getFilename())
			end

			-- Check if everything fits in the source image like the descriptor says.
			local maxRowsInFont = math.floor((in_imageData:getHeight()-1) / in_lineDist)

			if rbmfFile.lastRow > maxRowsInFont then
				errorLine(
					"%s: Font descriptor specifies glyphs up to row %d but only %d rows fit. (Line height is %d, image height is %d)",
					imagePathObj:getFilename(), rbmfFile.lastRow, maxRowsInFont, in_lineHeight, in_imageData:getHeight()
				)
			end

			-- Collect all glyphs.
			--
			-- Note: The output should be stable even if we process rows out-of-order
			-- here because we sort the glyphs before determining layout and nothing
			-- else should be affected by the processing order. 2021-04-07
			--
			local filterCps      = (rbmfFile.useTextFiles and rbmfFile.textCodepoints or nil)
			local existingGlyphs = {}

			for row, cpsOnRow in pairs(rbmfFile.codepoints) do
				local x           = 1
				local y           = 1 + (row-1) * in_lineDist
				local glyphStartX = x

				for i, cp in ipairs(cpsOnRow) do
					existingGlyphs[cp] = true
					local xNext        = -1

					for x = x, in_imageData:getWidth()-1 do
						!GET_PIXEL(`in_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

						if r == sepR and g == sepG and b == sepB and a == sepA then
							xNext = x
							break
						end
					end

					if xNext < 0 then
						errorLine(
							"%s: Missing glyphs on row %d. (Expected %d, found %d)",
							imagePathObj:getFilename(), row, #cpsOnRow, i-1
						)
					end

					x = xNext

					if not (filterCps and not filterCps[cp]) then
						local glyphInfo = GlyphInfo(cp)
						glyphInfo.inX1  = glyphStartX
						glyphInfo.inY1  = y
						glyphInfo.inX2  = x - 1
						glyphInfo.inY2  = y + in_lineDist - 2
						glyphInfo.inW   = x - glyphStartX
						glyphInfo.inH   = in_lineHeight
						glyphInfo.inW0  = glyphInfo.inW
						table.insert(glyphs, glyphInfo)
					end

					x           = x + 1
					glyphStartX = x
				end
			end

			-- Check for missing glyphs.
			for cp in pairs(rbmfFile.textCodepoints) do
				if not existingGlyphs[cp] then
					table.insert(rbmfFile.missingCodepoints, cp)
				end
			end

			warnAboutAnyMissingCodepoints(rbmfFile.missingCodepoints, rbmfFile.path)
		end

		----------------------------------------------------------------

		if not glyphs[1] then
			fileError(rbmfFile, "No glyphs to export.")
		end

		--
		-- Edit input image
		--
		if rbmfFile.editAlphaThreshold > 0 then
			-- Need to @Revise all this! 2021-03-21
			local threshold = rbmfFile.editAlphaThreshold

			local function applyAlphaThreshold(x,y, r,g,b,a)
				return r, g, b, (a >= threshold and 1 or 0)
			end

			for _, glyphInfo in ipairs(glyphs) do
				local x1, x2, y1, y2 = getImageContentBounds(in_imageData, glyphInfo.inX1, glyphInfo.inY1, glyphInfo.inX2, glyphInfo.inY2, .0001)
				if x1 then
					in_imageData:mapPixel(applyAlphaThreshold, x1,y1, x2-x1+1,y2-y1+1) -- @Speed
				end
			end
		end

		--
		-- Trim glyphs
		--
		if rbmfFile.editTrimGlyphs then
			for _, glyphInfo in ipairs(glyphs) do
				local x1, x2, y1, y2 = getImageContentBounds(in_imageData, glyphInfo.inX1, glyphInfo.inY1, glyphInfo.inX2, glyphInfo.inY2, .0001)

				if not x1 then
					glyphInfo.inX1 = 0
					glyphInfo.inY1 = 0
					glyphInfo.inX2 = 0
					glyphInfo.inY2 = 0
					glyphInfo.inW  = 0
					glyphInfo.inH  = 0

				else
					glyphInfo.inOffsetX = x1 - glyphInfo.inX1
					glyphInfo.inOffsetY = y1 - glyphInfo.inY1

					glyphInfo.inX1 = x1
					glyphInfo.inX2 = x2
					glyphInfo.inY1 = y1
					glyphInfo.inY2 = y2
					glyphInfo.inW  = x2 - x1 + 1
					glyphInfo.inH  = y2 - y1 + 1
				end
			end
		end

		--
		-- Write output images and descriptors
		--
		for outIndex, outDescr in ipairs(rbmfFile.outputDescriptors) do
			-- @Feature: Automatic kerning calculations?

			outDescr.couldPack = not (rbmfFile.isColored or outDescr.outlineWidth > 0) and isColor(outDescr.glyphColor, 1,1,1,1)
			outDescr.pack      = false--outDescr.couldPack -- LÖVE does not seem to support packing yet as of 11.3.

			-- Determine glyphs sizes (for this output).
			do
				local glyphExtraSizeX = 2*outDescr.outlineWidth + (outDescr.glyphPaddingL+outDescr.glyphPaddingR) * outDescr.mipmapAlignment
				local glyphExtraSizeY = 2*outDescr.outlineWidth + (outDescr.glyphPaddingU+outDescr.glyphPaddingD) * outDescr.mipmapAlignment

				local alignment = outDescr.mipmapAlignment

				local ceil = math.ceil

				for _, glyphInfo in ipairs(glyphs) do
					if glyphInfo.inW > 0 then
						glyphInfo.outW = ceil((glyphInfo.inW + glyphExtraSizeX) / alignment) * alignment
						glyphInfo.outH = ceil((glyphInfo.inH + glyphExtraSizeY) / alignment) * alignment
					end
				end
			end

			-- Make it easier to pack glyphs somewhat tightly by sorting them by size.
			-- Note that we need to do this per output as glyph sizes may change.
			table.sort(glyphs, function(a, b)
				if a.outH ~= b.outH then  return a.outH > b.outH  end
				if a.outW ~= b.outW then  return a.outW > b.outW  end
				return a.cp < b.cp
			end)

			-- Determine page size and glyph layout.
			-- Note: The image dimensions must be the same for for all pages in BMFont.
			local pageWidth, pageHeight, pageCount

			if outDescr.imageBounds == "smallest" then
				local w, h, _pageCount = makeGlyphLayout(outDescr, glyphs, out_imageMaxSize, 1/0, true)
				pageWidth              = math.ceil(w / 2) * 2 -- Even numbers are safer than odd, yo.
				pageHeight             = math.ceil(h / 2) * 2
				pageCount              = _pageCount

			elseif outDescr.imageBounds == "poweroftwo" then
				local w, h, _pageCount = makeGlyphLayout(outDescr, glyphs, out_imageMaxSize, 1/0, true)
				pageWidth              = 2 ^ math.ceil(math.log(w) / math.log(2))
				pageHeight             = 2 ^ math.ceil(math.log(h) / math.log(2))
				pageCount              = _pageCount

			elseif outDescr.imageBounds == "poweroftwosquare" then
				local bestMaxSize   = out_imageMaxSize
				local bestPageCount = 1/0
				local maxSize       = bestMaxSize

				while maxSize >= 1 do
					local w, h, _pageCount = makeGlyphLayout(outDescr, glyphs, maxSize, bestPageCount, false)
					if not w then  break  end

					bestPageCount = _pageCount
					bestMaxSize   = maxSize

					maxSize = .5 * maxSize
				end

				local w, h, _pageCount = makeGlyphLayout(outDescr, glyphs, bestMaxSize, 1/0, true)
				pageWidth              = 2 ^ math.ceil(math.log(math.max(w, h)) / math.log(2))
				pageHeight             = pageWidth
				pageCount              = _pageCount

			else
				error(outDescr.imageBounds)
			end

			if pageWidth > out_imageMaxSize or pageHeight > out_imageMaxSize then
				errorLine(
					"Image '%s' need a bigger size limit than %dx%d. (The calculated minimum size became %.0fx%.0f)",
					outDescr.pathImage, out_imageMaxSize, out_imageMaxSize, pageWidth, pageHeight
				)
			end

			local out_imageDatas = {}

			for imageIndex = 1, pageCount do
				out_imageDatas[imageIndex] = LI.newImageData(pageWidth, pageHeight)
			end

			-- Start writing descriptor.
			local out_descriptorBuffer = {}

			table.insert(out_descriptorBuffer, F(
				-- @Polish: Output correct value for 'smooth' and 'aa'. (Is this always possible, or ever useful?)
				-- @Polish: Maybe have a way of specifying 'bold' and 'italic' (though it's probably useless information).
				-- @Polish: We can do more here, but it's all probably useless!
				'info face="" size=%d bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=0 aa=0 padding=%d,%d,%d,%d spacing=%d,%d outline=%d',
				in_lineHeight, -- size
				outDescr.glyphPaddingU*outDescr.mipmapAlignment, outDescr.glyphPaddingR*outDescr.mipmapAlignment, outDescr.glyphPaddingD*outDescr.mipmapAlignment, outDescr.glyphPaddingL*outDescr.mipmapAlignment, -- padding
				outDescr.glyphSpacingH, outDescr.glyphSpacingV, -- spacing
				outDescr.outlineWidth -- outline
			))
			for _, k in ipairs(outDescr.customValues) do
				local v = outDescr.customValues[k]
				table.insert(out_descriptorBuffer, F(" CUSTOM_%s=", k))
				table.insert(out_descriptorBuffer, v:find"^%-?%d*%.?%d+$" and v or F('"%s"', v))
			end
			table.insert(out_descriptorBuffer, "\n")

			local out_lineHeight = (
				in_lineHeight
				+ (outDescr.paddingAffectsRenderSpacing and (outDescr.glyphPaddingU+outDescr.glyphPaddingD)*outDescr.mipmapAlignment or 0)
				+ (outDescr.outlineAffectsRenderSpacing and outDescr.outlineWidth or 0)
			)

			table.insert(out_descriptorBuffer, F(
				'common lineHeight=%d base=%d scaleW=%d scaleH=%d pages=%d packed=%d alphaChnl=0 redChnl=0 greenChnl=0 blueChnl=0\n',
				out_lineHeight, -- lineHeight
				out_lineHeight, -- base  @Incomplete: Some way of specifying this. (Probably low priority.)
				pageWidth, pageHeight, -- scaleW, scaleH
				#out_imageDatas, -- pages
				(outDescr.pack and 1 or 0) -- packed
			))

			-- Write glyphs.
			for imageIndex = 1, #out_imageDatas do
				table.insert(out_descriptorBuffer, F('page id=%d file="%s"\n', imageIndex-1, outputImageFilenameBaseToFilename(outDescr.filenameImage, imageIndex)))
			end

			table.insert(out_descriptorBuffer, F('chars count=%d\n', #glyphs))

			-- for _, data in ipairs(out_imageDatas) do  data:mapPixel(function(x,y, r,g,b,a)  return 1, 0, 0, 1  end)  end -- DEBUG: Show areas we don't paste glyphs in.

			if outDescr.pack then
				!GET_IMAGE_DATA_POINTER `in_imageData`

				for imageIndex, out_imageData in ipairs(out_imageDatas) do
					!GET_IMAGE_DATA_POINTER `out_imageData`

					for _, glyphInfo in ipairs(glyphs) do
						if glyphInfo.outImageIndex == imageIndex and glyphInfo.outW > 0 then
							local outX1 = glyphInfo.outX + outDescr.glyphPaddingL * outDescr.mipmapAlignment -- Note: Packed glyphs have no outlines.
							local outY1 = glyphInfo.outY + outDescr.glyphPaddingU * outDescr.mipmapAlignment
							local outX2 = outX1 + glyphInfo.inW - 1
							local outY2 = outY1 + glyphInfo.inH - 1

							local dx = glyphInfo.inX1 - outX1
							local dy = glyphInfo.inY1 - outY1

							if glyphInfo.outChannel == 1 then
								for outY = outY1, outY2 do
									for outX = outX1, outX2 do
										!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
										!SET_PIXEL(`out_imageData`, `outX`,`outY`, `a`,nil,nil,nil)
									end
								end
							elseif glyphInfo.outChannel == 2 then
								for outY = outY1, outY2 do
									for outX = outX1, outX2 do
										!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
										!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,`a`,nil,nil)
									end
								end
							elseif glyphInfo.outChannel == 3 then
								for outY = outY1, outY2 do
									for outX = outX1, outX2 do
										!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
										!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,nil,`a`,nil)
									end
								end
							else--if glyphInfo.outChannel == 4 then
								for outY = outY1, outY2 do
									for outX = outX1, outX2 do
										!GET_PIXEL(`in_imageData`, nil,nil,nil,`a`, `outX+dx`,`outY+dy`)
										!SET_PIXEL(`out_imageData`, `outX`,`outY`, nil,nil,nil,`a`)
									end
								end
							end
						end
					end
				end

			else
				for _, glyphInfo in ipairs(glyphs) do
					if glyphInfo.outW > 0 then
						out_imageDatas[glyphInfo.outImageIndex]:paste(
							in_imageData,
							glyphInfo.outX + outDescr.glyphPaddingL * outDescr.mipmapAlignment + outDescr.outlineWidth, -- dx
							glyphInfo.outY + outDescr.glyphPaddingU * outDescr.mipmapAlignment + outDescr.outlineWidth, -- dy
							glyphInfo.inX1, -- sx
							glyphInfo.inY1, -- sy
							glyphInfo.inW,  -- sw
							glyphInfo.inH   -- sh
						)
					end
				end

				if outDescr.couldPack then
					for _, out_imageData in ipairs(out_imageDatas) do
						!GET_IMAGE_DATA_POINTER `out_imageData`

						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							!GET_PIXEL(`out_imageData`, nil,nil,nil,`a`, `x`,`y`)
							!SET_PIXEL(`out_imageData`, `x`,`y`, 1,1,1,`a`)
						!MAP_PIXEL_END()
					end

				elseif not isColor(outDescr.glyphColor, 1,1,1,1) then
					local glyphR, glyphG, glyphB, glyphA = unpack(outDescr.glyphColor)

					for _, out_imageData in ipairs(out_imageDatas) do
						!GET_IMAGE_DATA_POINTER `out_imageData`

						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							!GET_PIXEL(`out_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)
							!SET_PIXEL(`out_imageData`, `x`,`y`, `r*glyphR`,`g*glyphG`,`b*glyphB`,`a*glyphA`)
						!MAP_PIXEL_END()
					end
				end
			end

			-- for _, data in ipairs(out_imageDatas) do  data:mapPixel(function(x,y, r,g,b,a)  return r, g, b, 1  end)  end -- DEBUG: Show as fully opaque / discard (glyphs in) alpha channel.

			for _, glyphInfo in ipairs(glyphs) do
				local xAdvance = (
					glyphInfo.inW0
					+ outDescr.renderSpacing
					+ (outDescr.paddingAffectsRenderSpacing and (outDescr.glyphPaddingL+outDescr.glyphPaddingR)*outDescr.mipmapAlignment or 0)
					+ (outDescr.outlineAffectsRenderSpacing and outDescr.outlineWidth or 0)
				)
				table.insert(out_descriptorBuffer, F(
					'char id=%d x=%d y=%d width=%d height=%d xoffset=%d yoffset=%d xadvance=%d page=%d chnl=%d\n',
					glyphInfo.cp, -- id
					glyphInfo.outX, glyphInfo.outY, -- x, y
					glyphInfo.outW, glyphInfo.outH, -- width, height
					glyphInfo.inOffsetX, glyphInfo.inOffsetY, -- xoffset, yoffset
					xAdvance, -- xadvance
					glyphInfo.outImageIndex-1, -- page
					(outDescr.pack and 2^(glyphInfo.outChannel-1) or 15) -- chnl
				))
			end

			-- Add glyph outlines.
			if outDescr.outlineWidth > 0 then
				assert(not outDescr.pack)

				local w = pageWidth
				local h = pageHeight

				local readonlyImageData = LI.newImageData(w, h)
				!GET_IMAGE_DATA_POINTER `readonlyImageData`

				local outlineWidth                           = outDescr.outlineWidth
				local outlineWidthSq                         = outlineWidth^2
				local outlineR, outlineG, outlineB, outlineA = unpack(outDescr.outlineColor)

				for _, out_imageData in ipairs(out_imageDatas) do
					readonlyImageData:paste(out_imageData, 0,0, 0,0, w,h)

					!GET_IMAGE_DATA_POINTER `out_imageData`

					local min = math.min
					local max = math.max

					if outlineWidth == 1 and outDescr.outlineMethod ~= "basic" then
						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							!(
							GET_PIXEL(`out_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`au`,  `    x        `,`max(y-1, 0  )`)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`aur`, `min(x+1, w-1)`,`max(y-1, 0  )`)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`ar`,  `min(x+1, w-1)`,`    y        `)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`adr`, `min(x+1, w-1)`,`min(y+1, h-1)`)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`ad`,  `    x        `,`min(y+1, h-1)`)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`adl`, `max(x-1, 0  )`,`min(y+1, h-1)`)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`al`,  `max(x-1, 0  )`,`    y        `)
							GET_PIXEL(`readonlyImageData`, nil,nil,nil,`aul`, `max(x-1, 0  )`,`max(y-1, 0  )`)

							local DIAGONAL_SIGNIFICANCE = .4
							)

							local neighborAlpha = max(
								au,
								aur * !(DIAGONAL_SIGNIFICANCE),
								ar,
								adr * !(DIAGONAL_SIGNIFICANCE),
								ad,
								adl * !(DIAGONAL_SIGNIFICANCE),
								al,
								aul * !(DIAGONAL_SIGNIFICANCE),
								a
							)

							r = r*a + (1-a)*outlineR
							g = g*a + (1-a)*outlineG
							b = b*a + (1-a)*outlineB
							a = a   + (1-a)*outlineA*neighborAlpha

							!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,`a`, true)
							-- !SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,`a`, true) -- DEBUG: Show result in mono-color.
							-- if neighborAlpha == 0 then  !(do SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,1, true) end)  end -- DEBUG: Show unaffected pixels.
						!MAP_PIXEL_END()

					else
						--
						-- This doesn't look very good for partially diagonal lines in fonts with smooth
						-- edges/half-transparent pixels, but there's only so much that can be done when
						-- all we have are pixels. Maybe we can do something better for TrueType fonts?
						--
						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							!GET_PIXEL(`out_imageData`, `r`,`g`,`b`,`a`, `x`,`y`)

							local neighborAlpha = a

							for circleY = max(y-outlineWidth, 0), min(y+outlineWidth, h-1) do
								for circleX = max(x-outlineWidth, 0), min(x+outlineWidth, w-1) do
									local distSq = (circleX-x)*(circleX-x) + (circleY-y)*(circleY-y)

									-- if distSq <= outlineWidthSq then
										!GET_PIXEL(`readonlyImageData`, nil,nil,nil,`circleA`, `circleX`,`circleY`)

										-- This doesn't look good in some cases if there are full shapes with half-
										-- transparent pixels (generally if the font is a bit too thin in places).
										-- We use the next piece of code instead!
										-- neighborAlpha = max(neighborAlpha, circleA*min(max(outlineWidth-distSq^.5, 0), 1))

										if circleA > .4 then -- @Hardcoded alpha threshold. (How does e.g. Photoshop create outline effects on layers? I think they use a threshold similar to this.)
											neighborAlpha = max(neighborAlpha, min(outlineWidth-distSq^.5+1, 1)) -- (Why is +1 needed here for the result to be correct?)

											-- Maybe something like this would be better than the above? Also, maybe we should
											-- support float widths for outlines? That would achieve the same effect I think.
											-- neighborAlpha = max(neighborAlpha, min(max(outlineWidth-distSq^.5-.3, 0), 1))
										end
									-- end
								end
							end

							r = r*a + (1-a)*outlineR
							g = g*a + (1-a)*outlineG
							b = b*a + (1-a)*outlineB
							a = a   + (1-a)*outlineA*neighborAlpha

							!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,`a`, true)
							-- !SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,`a`, true) -- DEBUG: Show result in mono-color.
							-- if neighborAlpha == 0 then  !(do SET_PIXEL(`out_imageData`, `x`,`y`, 1,0,0,1, true) end)  end -- DEBUG: Show unaffected pixels.
						!MAP_PIXEL_END()
					end
				end--for out_imageDatas
			end--if outlineWidth > 0

			--
			-- Try to ensure linear interpolation will work properly when
			-- rendering in-game. (Try, because LÖVE currently doesn't do the
			-- right thing... Maybe someday it will! 2021-03-29)
			--
			-- If alignForMipmapLevels is 1 we only change pixels directly
			-- around non-transparent pixels - otherwise we change all pixels.
			-- Note that the algorithm currently doesn't consider glyph
			-- bounds, which it probably should!
			--
			-- @Incomplete: Maybe there should be a setting to skip this step if it's not of importance.
			--
			if not outDescr.couldPack and outDescr.outlineWidth == 0 then
				local w = pageWidth
				local h = pageHeight

				local min = math.min
				local max = math.max

				for _, out_imageData in ipairs(out_imageDatas) do
					!GET_IMAGE_DATA_POINTER `out_imageData`

					if outDescr.alignForMipmapLevels > 1 then
						local maxRadius = math.max(w, h) -- @Speed: Maybe we can use some lower value here?

						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							-- Note: We don't need to use a readonlyImageData as we only write to transparent
							-- pixels and we only read/use values from non-transparent pixels.
							!GET_PIXEL(`out_imageData`, nil,nil,nil,`a`, `x`,`y`)

							if a == 0 then
								local weight = 0

								for radius = 1, maxRadius do
									local x1 = max(x-radius, 0)
									local y1 = max(y-radius, 0)
									local x2 = min(x+radius, w-1)
									local y2 = min(y+radius, h-1)

									local dist = 0

									for _dist = 0, radius do
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a1`, `max(x-_dist, x1)`,`y1`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a2`, `min(x+_dist, x2)`,`y1`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a3`, `x1`,`max(y-_dist, y1)`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a4`, `x2`,`max(y-_dist, y1)`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a5`, `x1`,`min(y+_dist, y2)`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a6`, `x2`,`min(y+_dist, y2)`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a7`, `max(x-_dist, x1)`,`y2`)
										!GET_PIXEL(`out_imageData`, nil,nil,nil,`a8`, `min(x+_dist, x2)`,`y2`)

										weight = weight + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8

										if weight > 0 then
											dist = _dist
											break
										end
									end

									if weight > 0 then
										!GET_PIXEL(`out_imageData`, `r1`,`g1`,`b1`,`a1`, `max(x-dist, x1)`,`y1`)
										!GET_PIXEL(`out_imageData`, `r2`,`g2`,`b2`,`a2`, `min(x+dist, x2)`,`y1`)
										!GET_PIXEL(`out_imageData`, `r3`,`g3`,`b3`,`a3`, `x1`,`max(y-dist, y1)`)
										!GET_PIXEL(`out_imageData`, `r4`,`g4`,`b4`,`a4`, `x2`,`max(y-dist, y1)`)
										!GET_PIXEL(`out_imageData`, `r5`,`g5`,`b5`,`a5`, `x1`,`min(y+dist, y2)`)
										!GET_PIXEL(`out_imageData`, `r6`,`g6`,`b6`,`a6`, `x2`,`min(y+dist, y2)`)
										!GET_PIXEL(`out_imageData`, `r7`,`g7`,`b7`,`a7`, `max(x-dist, x1)`,`y2`)
										!GET_PIXEL(`out_imageData`, `r8`,`g8`,`b8`,`a8`, `min(x+dist, x2)`,`y2`)

										local r = (r1*a1 + r2*a2 + r3*a3 + r4*a4 + r5*a5 + r6*a6 + r7*a7 + r8*a8) / weight
										local g = (g1*a1 + g2*a2 + g3*a3 + g4*a4 + g5*a5 + g6*a6 + g7*a7 + g8*a8) / weight
										local b = (b1*a1 + b2*a2 + b3*a3 + b4*a4 + b5*a5 + b6*a6 + b7*a7 + b8*a8) / weight

										!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,nil)
										break
									end
								end--for radius

								if weight == 0 then
									break -- We only get here if all pixels are transparent.
								end
							end
						!MAP_PIXEL_END()

					else--if outDescr.alignForMipmapLevels == 1 then
						!MAP_PIXEL(`out_imageData`, `x`,`y`)
							-- Note: We don't need to use a readonlyImageData as we only write to transparent
							-- pixels and we only read/use values from non-transparent pixels.
							!GET_PIXEL(`out_imageData`, nil,nil,nil,`a`, `x`,`y`)

							if a == 0 then
								!GET_PIXEL(`out_imageData`, nil,nil,nil,`a1`, `    x        `,`max(y-1, 0  )`)
								!GET_PIXEL(`out_imageData`, nil,nil,nil,`a2`, `max(x-1, 0  )`,`    y        `)
								!GET_PIXEL(`out_imageData`, nil,nil,nil,`a3`, `min(x+1, w-1)`,`    y        `)
								!GET_PIXEL(`out_imageData`, nil,nil,nil,`a4`, `    x        `,`min(y+1, h-1)`)

								local weight = a1 + a2 + a3 + a4

								if weight > 0 then
									!GET_PIXEL(`out_imageData`, `r1`,`g1`,`b1`,nil, `    x        `,`max(y-1, 0  )`)
									!GET_PIXEL(`out_imageData`, `r2`,`g2`,`b2`,nil, `max(x-1, 0  )`,`    y        `)
									!GET_PIXEL(`out_imageData`, `r3`,`g3`,`b3`,nil, `min(x+1, w-1)`,`    y        `)
									!GET_PIXEL(`out_imageData`, `r4`,`g4`,`b4`,nil, `    x        `,`min(y+1, h-1)`)

									local r = (r1*a1 + r2*a2 + r3*a3 + r4*a4) / weight
									local g = (g1*a1 + g2*a2 + g3*a3 + g4*a4) / weight
									local b = (b1*a1 + b2*a2 + b3*a3 + b4*a4) / weight

									!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,nil)

								else
									!GET_PIXEL(`out_imageData`, nil,nil,nil,`a1`, `max(x-1, 0  )`,`max(y-1, 0  )`)
									!GET_PIXEL(`out_imageData`, nil,nil,nil,`a2`, `min(x+1, w-1)`,`max(y-1, 0  )`)
									!GET_PIXEL(`out_imageData`, nil,nil,nil,`a3`, `max(x-1, 0  )`,`min(y+1, h-1)`)
									!GET_PIXEL(`out_imageData`, nil,nil,nil,`a4`, `min(x+1, w-1)`,`min(y+1, h-1)`)

									weight = a1 + a2 + a3 + a4

									if weight > 0 then
										!GET_PIXEL(`out_imageData`, `r1`,`g1`,`b1`,nil, `max(x-1, 0  )`,`max(y-1, 0  )`)
										!GET_PIXEL(`out_imageData`, `r2`,`g2`,`b2`,nil, `min(x+1, w-1)`,`max(y-1, 0  )`)
										!GET_PIXEL(`out_imageData`, `r3`,`g3`,`b3`,nil, `max(x-1, 0  )`,`min(y+1, h-1)`)
										!GET_PIXEL(`out_imageData`, `r4`,`g4`,`b4`,nil, `min(x+1, w-1)`,`min(y+1, h-1)`)

										local r = (r1*a1 + r2*a2 + r3*a3 + r4*a4) / weight
										local g = (g1*a1 + g2*a2 + g3*a3 + g4*a4) / weight
										local b = (b1*a1 + b2*a2 + b3*a3 + b4*a4) / weight

										!SET_PIXEL(`out_imageData`, `x`,`y`, `r`,`g`,`b`,nil)

									else
										-- Stomp unimportant pixels for better compression.
										-- We assume white is the dominant color in the image.
										!SET_PIXEL(`out_imageData`, `x`,`y`, 1,1,1,nil)
									end
								end
							end
						!MAP_PIXEL_END()
					end
				end--for out_imageDatas
			end

			-- for _, data in ipairs(out_imageDatas) do  data:mapPixel(function(x,y, r,g,b,a)  return r, g, b, 1  end)  end -- DEBUG: Show as fully opaque.
			-- for _, data in ipairs(out_imageDatas) do  data:mapPixel(function(x,y, r,g,b,a)  if a > 0 then  return r, g, b, 1  else  return (r+g+b)/3, 0, 0, 1  end  end)  end -- DEBUG: Show as fully opaque with red indicating transparency.

			-- Write kernings.
			local kerningPairs = {}

			for pair in pairs(rbmfFile.kernings) do
				table.insert(kerningPairs, pair)
			end

			if kerningPairs[1] then
				table.sort(kerningPairs)

				table.insert(out_descriptorBuffer, F('kernings count=%d\n', #kerningPairs))

				for _, pair in ipairs(kerningPairs) do
					local first, second = pair:match(F("(%s)(%s)", utf8.charpattern, utf8.charpattern))
					first               = utf8.codepoint(first)
					second              = utf8.codepoint(second)

					local offset = rbmfFile.kernings[pair]

					table.insert(out_descriptorBuffer, F('kerning first=%d second=%d amount=%d\n', first, second, offset))
				end
			end

			-- Save files.
			if outDescr.filenameImage ~= "" then
				local pathObj           = Path(outDescr.filenameImage, rbmfFile.outDirectory)
				local dir, filenameBase = pathObj:getDirectoryAndFilename()

				for imageIndex, out_imageData in ipairs(out_imageDatas) do
					local filename = outputImageFilenameBaseToFilename(filenameBase, imageIndex)
					pathObj:setFilename(filename)

					printf("Writing image: %s", pathObj:toString())
					reservePathForWriting(pathObj:toString(), "output(%d) image for '%s'", outIndex, rbmfFile.path)

					mustConnectToDirectory(dir)
					if not out_imageData:encode(outDescr.imageEncoding, filename) then
						errorLine("Could not write font image '%s'.", pathObj:toString())
					end
				end

				-- Delete old extra pages.
				for imageIndex = #out_imageDatas+1, 2^52 do
					local filename = outputImageFilenameBaseToFilename(filenameBase, imageIndex)
					pathObj:setFilename(filename)

					if not LF.getInfo(filename, "file") then  break  end

					printf("Deleting old image: %s", pathObj:toString())
					if not LF.remove(filename) then
						warning("Could not delete file '%s'.", pathObj:toString())
					end
				end
			end

			if outDescr.filenameDescriptor ~= "" then
				local pathObj       = Path(outDescr.filenameDescriptor, rbmfFile.outDirectory)
				local dir, filename = pathObj:getDirectoryAndFilename()

				printf("Writing descriptor: %s", pathObj:toString())
				reservePathForWriting(pathObj:toString(), "output(%d) descriptor for '%s'", outIndex, rbmfFile.path)

				mustConnectToDirectory(dir)
				local ok, err = LF.write(filename, table.concat(out_descriptorBuffer))
				if not ok then
					errorLine("Could not write font descriptor '%s'. (%s)", pathObj:toString(), err)
				end
			end
		end--for rbmfFile.outputDescriptors
	end--for rbmfFiles

	--
	-- Write icons file
	--
	local triedWritingIcons = false

	if out_iconsPath ~= "" then
		local icons = getIcons()

		-- Should we always write the icons file? (This is probably never an
		-- issue as it seems unlikely that someone will define icons at some
		-- point but later change their mind and remove them all, thus leaving
		-- this file with garbage in it.)
		if icons[1] then
			local buffer = {}

			for _, icon in ipairs(icons) do
				local cp = getIconCodepoint(icon)
				table.insert(buffer, F("%d %s\n", cp, icon))
			end

			local pathObj       = Path(out_iconsPath)
			local dir, filename = pathObj:getDirectoryAndFilename()

			printf("Writing icons file: %s", pathObj:toString())
			reservePathForWriting(pathObj:toString(), "output icons file")

			mustConnectToDirectory(dir)
			local ok, err = LF.write(filename, table.concat(buffer))
			if not ok then
				errorLine("Could not write icons file '%s'. (%s)", pathObj:toString(), err)
			end

			triedWritingIcons = true
		end
	end

	if not triedWritingIcons then
		printf("No icons file written.")
	end

	--
	-- Write missing characters file
	--
	if out_missingPath ~= "" then
		local allMissingCps    = {}
		local allMissingCpsSet = {}

		local pathObj       = Path(out_missingPath)
		local dir, filename = pathObj:getDirectoryAndFilename()

		if out_mergeMissing and isFile(pathObj:toString()) then
			printf("Loading missing characters file: %s", pathObj:toString())

			local s, err = getFileContents(pathObj)
			if not s then
				errorLine("Could not open missing characters file '%s'. (%s)", pathObj:toString(), err)
			end

			for _, cp in utf8.codes(s) do
				if not allMissingCpsSet[cp] then
					allMissingCpsSet[cp] = true
					table.insert(allMissingCps, cp)
				end
			end
		end

		for _, rbmfFile in ipairs(rbmfFiles) do
			for _, cp in ipairs(rbmfFile.missingCodepoints) do
				if not allMissingCpsSet[cp] then
					allMissingCpsSet[cp] = true
					table.insert(allMissingCps, cp)
				end
			end
		end

		table.sort(allMissingCps)

		local buffer = {}

		for _, cp in ipairs(allMissingCps) do
			table.insert(buffer, utf8.char(cp))
		end

		printf("Writing missing characters file (%d codepoints): %s", #allMissingCps, pathObj:toString())
		reservePathForWriting(pathObj:toString(), "output missing characters file")

		mustConnectToDirectory(dir)
		local ok, err = LF.write(filename, table.concat(buffer))
		if not ok then
			errorLine("Could not write missing characters file '%s'. (%s)", pathObj:toString(), err)
		end
	end

	--
	-- All done!
	--
	local endTime = socket.gettime()

	print!(CMD_SEPARATOR)
	if warningCount > 0 then
		printf("Completed with %d warning%s!", warningCount, S(warningCount))
	else
		print("Completed successfully!")
	end
	printf("Time:  %.3f seconds", endTime-startTime)
	printf("Icons: %d", getIconCount())
	!if DEV then
	printf("Mem:   %d KiB", collectgarbage"count")
	!end
	print!(CMD_SEPARATOR)
	print()

	return function()
		-- return 0 -- This sometimes crashes us for some reason. Is there a race condition somewhere or something? Who the hell knows, so we do the following instead...
		os.exit(0)
	end
end



!else--if TEST then

function love.load()
	io.stdout:setvbuf"no"
	io.stderr:setvbuf"no"

	_G.LG = love.graphics

	_G.fontIndex = 1

	_G.scalePower = 2

	_G.info      = ""
	_G.infoAlpha = 0

	loadOrReload()
end

function _G.loadOrReload()
	-- love.graphics.setDefaultFilter("nearest")

	_G.fonts = {
		love.graphics.newFont("temp/smallPixel.fnt"),
		love.graphics.newFont("temp/smallPixel_outline.fnt"),
		love.graphics.newFont("temp/vector.fnt"),
		love.graphics.newFont("temp/vector_outline.fnt"),
	}

	_G.icons = {}

	for line in love.filesystem.lines("temp/.fonticons") do
		local cp, name = line:match"(%d+) (%S+)"
		icons[name]    = require"utf8".char(tonumber(cp))
	end

	_G.text = ("Hello, world!\nPress {psx} to begin"):gsub("{(%w+)}", icons)
end

function love.keypressed(key)
	if key == "escape" then
		love.event.quit()

	elseif key == "f5" then
		info      = "Reloading..."
		infoAlpha = 1
		loadOrReload()

	elseif key == "1" then
		fontIndex = 1
	elseif key == "2" then
		fontIndex = 2
	elseif key == "3" then
		fontIndex = 3
	elseif key == "4" then
		fontIndex = 4

	elseif key == "+" or key == "kp+" then
		scalePower = scalePower + 1
	elseif key == "-" or key == "kp-" then
		scalePower = scalePower - 1
	end
end

function love.update(dt)
	infoAlpha = math.max(infoAlpha-dt/0.60, 0)
end

function love.draw()
	love.graphics.clear(.3, .3, .3, 1)

	if info ~= "" then
		love.graphics.push("all")
		love.graphics.setColor(1, 1, 1, infoAlpha)
		love.graphics.print(info)
		love.graphics.pop()
	end

	love.graphics.push("all")
	love.graphics.setFont(fonts[fontIndex])
	love.graphics.scale(2^scalePower)
	love.graphics.print(text, 5, 5)
	love.graphics.pop()
end

!end


